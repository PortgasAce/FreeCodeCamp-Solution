{"./":{"url":"./","title":"introduction","keywords":"","body":"FreeCodeCamp Solution 在FreeCodeCamp上解题，有时候即使答案正确也不会通过，这是FreeCodeCamp的bug。为了方便其他人，这里记录了FreeCodeCamp的正确解题答案。 "},"react.html":{"url":"react.html","title":"React","keywords":"","body":"Introduction to the React Challenges React, popularized by Facebook, is a open-source JavaScript library for building user interfaces. With JSX, it is used to create components, handle state and props, utilize event listeners and certain life cycle methods to update data as it changes. React combines HTML with JavaScript functionality to create its own markup language, JSX. This section will introduce you to all of these concepts and how to implement them for use with your own projects. "},"react-pass-state-as-props-to-child-components.html":{"url":"react-pass-state-as-props-to-child-components.html","title":"React: Pass State as Props to Child Components","keywords":"","body":"React: Pass State as Props to Child Components You saw a lot of examples that passed props to child JSX elements and child React components in previous challenges. You may be wondering where those props come from. A common pattern is to have a stateful component containing the state important to your app, that then renders child components. You want these components to have access to some pieces of that state, which are passed in as props. For example, maybe you have an App component that renders a Navbar, among other components. In your App, you have state that contains a lot of user information, but the Navbar only needs access to the user's username so it can display it. You pass that piece of state to the Navbar component as a prop. This pattern illustrates some important paradigms in React. The first is unidirectional data flow. State flows in one direction down the tree of your application's components, from the stateful parent component to child components. The child components only receive the state data they need. The second is that complex stateful apps can be broken down into just a few, or maybe a single, stateful component. The rest of your components simply receive state from the parent as props, and render a UI from that state. It begins to create a separation where state management is handled in one part of code and UI rendering in another. This principle of separating state logic from UI logic is one of React's key principles. When it's used correctly, it makes the design of complex, stateful applications much easier to manage. The MyApp component is stateful and renders a Navbar component as a child. Pass the name property in its state down to the child component, then show the name in the h1 tag that's part of the Navbar render method. class MyApp extends React.Component { constructor(props) { super(props); this.state = { name: 'CamperBot' } } render() { return ( ); } }; class Navbar extends React.Component { constructor(props) { super(props); } render() { return ( Hello, my name is: {this.props.name} ); } }; "},"react-pass-a-callback-as-props.html":{"url":"react-pass-a-callback-as-props.html","title":"React: Pass a Callback as Props","keywords":"","body":"React: Pass a Callback as Props You can pass state as props to child components, but you're not limited to passing data. You can also pass handler functions or any method that's defined on a React component to a child component. This is how you allow child components to interact with their parent components. You pass methods to a child just like a regular prop. It's assigned a name and you have access to that method name under this.props in the child component. There are three components outlined in the code editor. The MyApp component is the parent that will render the GetInput and RenderInput child components. Add the GetInput component to the render method in MyApp, then pass it a prop called input assigned to inputValue from MyApp's state. Also create a prop called handleChange and pass the input handler handleChange to it. Next, add RenderInput to the render method in MyApp, then create a prop called input and pass the inputValue from state to it. Once you are finished you will be able to type in the input field in the GetInput component, which then calls the handler method in its parent via props. This updates the input in the state of the parent, which is passed as props to both children. Observe how the data flows between the components and how the single source of truth remains the state of the parent component. Admittedly, this example is a bit contrived, but should serve to illustrate how data and callbacks can be passed between React components. class MyApp extends React.Component { constructor(props) { super(props); this.state = { inputValue: '' } this.handleChange = this.handleChange.bind(this); } handleChange(event) { this.setState({ inputValue: event.target.value }); } render() { return ( { /* change code below this line */ } { /* change code above this line */ } ); } }; class GetInput extends React.Component { constructor(props) { super(props); } render() { return ( Get Input: ); } }; class RenderInput extends React.Component { constructor(props) { super(props); } render() { return ( Input Render: {this.props.input} ); } }; "},"react-use-the-lifecycle-method-componentwillmount.html":{"url":"react-use-the-lifecycle-method-componentwillmount.html","title":"React: Use the Lifecycle Method componentWillMount","keywords":"","body":"React: Use the Lifecycle Method componentWillMount React components have several special methods that provide opportunities to perform actions at specific points in the lifecycle of a component. These are called lifecycle methods, or lifecycle hooks, and allow you to catch components at certain points in time. This can be before they are rendered, before they update, before they receive props, before they unmount, and so on. Here is a list of some of the main lifecycle methods: componentWillMount() componentDidMount() componentWillReceiveProps() shouldComponentUpdate() componentWillUpdate() componentDidUpdate() componentWillUnmount() The next several lessons will cover some of the basic use cases for these lifecycle methods. The componentWillMount() method is called before the render() method when a component is being mounted to the DOM. Log something to the console within componentWillMount() - you may want to have your browser console open to see the output. class MyComponent extends React.Component { constructor(props) { super(props); } componentWillMount() { // change code below this line console.log(\"componentWillMount\") // change code above this line } render() { return } }; "},"react-use-the-lifecycle-method-componentdidmount.html":{"url":"react-use-the-lifecycle-method-componentdidmount.html","title":"React: Use the Lifecycle Method componentDidMount","keywords":"","body":"React: Use the Lifecycle Method componentDidMount Most web developers, at some point, need to call an API endpoint to retrieve data. If you're working with React, it's important to know where to perform this action. The best practice with React is to place API calls or any calls to your server in the lifecycle method componentDidMount(). This method is called after a component is mounted to the DOM. Any calls to setState() here will trigger a re-rendering of your component. When you call an API in this method, and set your state with the data that the API returns, it will automatically trigger an update once you receive the data. There is a mock API call in componentDidMount(). It sets state after 2.5 seconds to simulate calling a server to retrieve data. This example requests the current total active users for a site. In the render method, render the value of activeUsers in the h1. Watch what happens in the preview, and feel free to change the timeout to see the different effects. class MyComponent extends React.Component { constructor(props) { super(props); this.state = { activeUsers: null }; } componentDidMount() { setTimeout( () => { this.setState({ activeUsers: 1273 }); }, 2500); } render() { return ( Active Users: { this.state.activeUsers } ); } }; "},"react-add-event-listeners.html":{"url":"react-add-event-listeners.html","title":"React: Add Event Listeners","keywords":"","body":"React: Add Event Listeners The componentDidMount() method is also the best place to attach any event listeners you need to add for specific functionality. React provides a synthetic event system which wraps the native event system present in browsers. This means that the synthetic event system behaves exactly the same regardless of the user's browser - even if the native events may behave differently between different browsers. You've already been using some of these synthetic event handlers such as onClick(). React's synthetic event system is great to use for most interactions you'll manage on DOM elements. However, if you want to attach an event handler to the document or window objects, you have to do this directly. Attach an event listener in the componentDidMount() method for keydown events and have these events trigger the callback handleKeyPress(). You can use document.addEventListener() which takes the event (in quotes) as the first argument and the callback as the second argument. Then, in componentWillUnmount(), remove this same event listener. You can pass the same arguments to document.removeEventListener(). It's good practice to use this lifecycle method to do any clean up on React components before they are unmounted and destroyed. Removing event listeners is an example of one such clean up action. class MyComponent extends React.Component { constructor(props) { super(props); this.state = { message: '' }; this.handleEnter = this.handleEnter.bind(this); this.handleKeyPress = this.handleKeyPress.bind(this); } // change code below this line componentDidMount() { document.addEventListener(\"keydown\",this.handleKeyPress); } componentWillUnmount() { document.removeEventListener(\"keydown\",this.handleKeyPress); } // change code above this line handleEnter() { this.setState({ message: this.state.message + 'You pressed the enter key! ' }); } handleKeyPress(event) { if (event.keyCode === 13) { this.handleEnter(); } } render() { return ( {this.state.message} ); } }; "},"react-manage-updates-with-lifecycle-methods.html":{"url":"react-manage-updates-with-lifecycle-methods.html","title":"React: Manage Updates with Lifecycle Methods","keywords":"","body":"React: Manage Updates with Lifecycle Methods Another lifecycle method is componentWillReceiveProps() which is called whenever a component is receiving new props. This method receives the new props as an argument, which is usually written as nextProps. You can use this argument and compare with this.props and perform actions before the component updates. For example, you may call setState() locally before the update is processed. Another method is componentDidUpdate(), and is called immediately after a component re-renders. Note that rendering and mounting are considered different things in the component lifecycle. When a page first loads, all components are mounted and this is where methods like componentWillMount() and componentDidMount() are called. After this, as state changes, components re-render themselves. The next challenge covers this in more detail. The child component Dialog receives message props from its parent, the Controller component. Write the componentWillReceiveProps() method in the Dialog component and have it log this.props and nextProps to the console. You'll need to pass nextProps as an argument to this method and although it's possible to name it anything, name it nextProps here. Next, add componentDidUpdate() in the Dialog component, and log a statement that says the component has updated. This method works similar to componentWillUpdate(), which is provided for you. Now click the button to change the message and watch your browser console. The order of the console statements show the order the methods are called. Note: You'll need to write the lifecycle methods as normal functions and not as arrow functions to pass the tests (there is also no advantage to writing lifecycle methods as arrow functions). class Dialog extends React.Component { constructor(props) { super(props); } componentWillUpdate() { console.log('Component is about to update...'); } // change code below this line componentWillReceiveProps(nextProps){ console.log('Component will receive props: '+this.props.message+\",next: \"+nextProps.message) } componentDidUpdate(){ console.log('Component will receive props: '+this.props.message) } // change code above this line render() { return {this.props.message} } }; class Controller extends React.Component { constructor(props) { super(props); this.state = { message: 'First Message' }; this.changeMessage = this.changeMessage.bind(this); } changeMessage() { this.setState({ message: 'Second Message' }); } render() { return ( Update ); } }; "},"react-optimize-re-renders-with-shouldcomponentupdate.html":{"url":"react-optimize-re-renders-with-shouldcomponentupdate.html","title":"React: Optimize Re-Renders with shouldComponentUpdate","keywords":"","body":"React: Optimize Re-Renders with shouldComponentUpdate So far, if any component receives new state or new props, it re-renders itself and all its children. This is usually okay. But React provides a lifecycle method you can call when child components receive new state or props, and declare specifically if the components should update or not. The method is shouldComponentUpdate(), and it takes nextProps and nextState as parameters. This method is a useful way to optimize performance. For example, the default behavior is that your component re-renders when it receives new props, even if the props haven't changed. You can use shouldComponentUpdate() to prevent this by comparing the props. The method must return a boolean value that tells React whether or not to update the component. You can compare the current props (this.props) to the next props (nextProps) to determine if you need to update or not, and return true or false accordingly. The shouldComponentUpdate() method is added in a component called OnlyEvens. Currently, this method returns true so OnlyEvens re-renders every time it receives new props. Modify the method so OnlyEvens updates only if the value of its new props is even. Click the Add button and watch the order of events in your browser's console as the other lifecycle hooks are triggered. class OnlyEvens extends React.Component { constructor(props) { super(props); } shouldComponentUpdate(nextProps, nextState) { console.log('Should I update?'); // change code below this line return nextProps.value%2 !== 1; // change code above this line } componentWillReceiveProps(nextProps) { console.log('Receiving new props...'); } componentDidUpdate() { console.log('Component re-rendered.'); } render() { return {this.props.value} } }; class Controller extends React.Component { constructor(props) { super(props); this.state = { value: 0 }; this.addValue = this.addValue.bind(this); } addValue() { this.setState({ value: this.state.value + 1 }); } render() { return ( Add ); } }; "},"react-introducing-inline-styles.html":{"url":"react-introducing-inline-styles.html","title":"React: Introducing Inline Styles","keywords":"","body":"React: Introducing Inline Styles There are other complex concepts that add powerful capabilities to your React code. But you may be wondering about the more simple problem of how to style those JSX elements you create in React. You likely know that it won't be exactly the same as working with HTML because of the way you apply classes to JSX elements. If you import styles from a stylesheet, it isn't much different at all. You apply a class to your JSX element using the className attribute, and apply styles to the class in your stylesheet. Another option is to apply inline styles, which are very common in ReactJS development. You apply inline styles to JSX elements similar to how you do it in HTML, but with a few JSX differences. Here's an example of an inline style in HTML: Mellow Yellow JSX elements use the style attribute, but because of the way JSX is transpiled, you can't set the value to a string. Instead, you set it equal to a JavaScript object. Here's an example: Mellow Yellow Notice how we camelCase the \"fontSize\" property? This is because React will not accept kebab-case keys in the style object. React will apply the correct property name for us in the HTML. Add a style attribute to the div in the code editor to give the text a color of red and font size of 72px. Note that you can optionally set the font size to be a number, omitting the units \"px\", or write it as \"72px\". class Colorful extends React.Component { render() { return ( Big Red ); } }; "},"react-add-inline-styles-in-react.html":{"url":"react-add-inline-styles-in-react.html","title":"React: Add Inline Styles in React","keywords":"","body":"React: Add Inline Styles in React You may have noticed in the last challenge that there were several other syntax differences from HTML inline styles in addition to the style attribute set to a JavaScript object. First, the names of certain CSS style properties use camel case. For example, the last challenge set the size of the font with fontSize instead of font-size. Hyphenated words like font-size are invalid syntax for JavaScript object properties, so React uses camel case. As a rule, any hyphenated style properties are written using camel case in JSX. All property value length units (like height, width, and fontSize) are assumed to be in px unless otherwise specified. If you want to use em, for example, you wrap the value and the units in quotes, like {fontSize: \"4em\"}. Other than the length values that default to px, all other property values should be wrapped in quotes. If you have a large set of styles, you can assign a style object to a constant to keep your code organized. Uncomment the styles constant and declare an object with three style properties and their values. Give the div a color of \"purple\", a font-size of 40, and a border of \"2px solid purple\". Then set the style attribute equal to the styles constant. const styles ={\"color\":\"purple\",\"fontSize\":40,\"border\":\"2px solid purple\"}; // change code above this line class Colorful extends React.Component { render() { // change code below this line return ( Style Me! ); // change code above this line } }; "},"react-use-advanced-javascript-in-react-render-method.html":{"url":"react-use-advanced-javascript-in-react-render-method.html","title":"React: Use Advanced JavaScript in React Render Method","keywords":"","body":"React: Use Advanced JavaScript in React Render Method In previous challenges, you learned how to inject JavaScript code into JSX code using curly braces, { }, for tasks like accessing props, passing props, accessing state, inserting comments into your code, and most recently, styling your components. These are all common use cases to put JavaScript in JSX, but they aren't the only way that you can utilize JavaScript code in your React components. You can also write JavaScript directly in your render methods, before the return statement, without inserting it inside of curly braces. This is because it is not yet within the JSX code. When you want to use a variable later in the JSX code inside the return statement, you place the variable name inside curly braces. In the code provided, the render method has an array that contains 20 phrases to represent the answers found in the classic 1980's Magic Eight Ball toy. The button click event is bound to the ask method, so each time the button is clicked a random number will be generated and stored as the randomIndex in state. On line 52, delete the string \"change me!\" and reassign the answer const so your code randomly accesses a different index of the possibleAnswers array each time the component updates. Finally, insert the answer const inside the p tags. const inputStyle = { width: 235, margin: 5 } class MagicEightBall extends React.Component { constructor(props) { super(props); this.state = { userInput: '', randomIndex: '' } this.ask = this.ask.bind(this); this.handleChange = this.handleChange.bind(this); } ask() { if (this.state.userInput) { this.setState({ randomIndex: Math.floor(Math.random() * 20), userInput: '' }); } } handleChange(event) { this.setState({ userInput: event.target.value }); } render() { const possibleAnswers = [ 'It is certain', 'It is decidedly so', 'Without a doubt', 'Yes, definitely', 'You may rely on it', 'As I see it, yes', 'Outlook good', 'Yes', 'Signs point to yes', 'Reply hazy try again', 'Ask again later', 'Better not tell you now', 'Cannot predict now', 'Concentrate and ask again', 'Don\\'t count on it', 'My reply is no', 'My sources say no', 'Most likely', 'Outlook not so good', 'Very doubtful' ]; const answer = possibleAnswers[this.state.randomIndex]; // Ask the Magic Eight Ball! Answer: { /* change code below this line */ } {answer} { /* change code above this line */ } ); } }; "},"react-render-with-an-ifelse-condition.html":{"url":"react-render-with-an-ifelse-condition.html","title":"React: Render with an If/Else Condition","keywords":"","body":"React: Render with an If/Else Condition Another application of using JavaScript to control your rendered view is to tie the elements that are rendered to a condition. When the condition is true, one view renders. When it's false, it's a different view. You can do this with a standard if/else statement in the render() method of a React component. MyComponent contains a boolean in its state which tracks whether you want to display some element in the UI or not. The button toggles the state of this value. Currently, it renders the same UI every time. Rewrite the render() method with an if/else statement so that if display is true, you return the current markup. Otherwise, return the markup without the h1 element. Note: You must write an if/else to pass the tests. Use of the ternary operator will not pass here. class MyComponent extends React.Component { constructor(props) { super(props); this.state = { display: true } this.toggleDisplay = this.toggleDisplay.bind(this); } toggleDisplay() { this.setState({ display: !this.state.display }); } render() { // change code below this line if(this.state.display){ return ( Toggle Display Displayed! ); }else{ return ( Toggle Display ); } } }; "},"react-use-andand-for-a-more-concise-conditional.html":{"url":"react-use-andand-for-a-more-concise-conditional.html","title":"React: Use && for a More Concise Conditional","keywords":"","body":"React: Use && for a More Concise Conditional The if/else statements worked in the last challenge, but there's a more concise way to achieve the same result. Imagine that you are tracking several conditions in a component and you want different elements to render depending on each of these conditions. If you write a lot of else if statements to return slightly different UIs, you may repeat code which leaves room for error. Instead, you can use the && logical operator to perform conditional logic in a more concise way. This is possible because you want to check if a condition is true, and if it is, return some markup. Here's an example: {condition && markup} If the condition is true, the markup will be returned. If the condition is false, the operation will immediately return false after evaluating the condition and return nothing. You can include these statements directly in your JSX and string multiple conditions together by writing && after each one. This allows you to handle more complex conditional logic in your render() method without repeating a lot of code. Solve the previous example again, so the h1 only renders if display is true, but use the && logical operator instead of an if/else statement. class MyComponent extends React.Component { constructor(props) { super(props); this.state = { display: true } this.toggleDisplay = this.toggleDisplay.bind(this); } toggleDisplay() { this.setState({ display: !this.state.display }); } render() { // change code below this line return ( Toggle Display {this.state.display && Displayed!} ); } }; "},"react-use-a-ternary-expression-for-conditional-rendering.html":{"url":"react-use-a-ternary-expression-for-conditional-rendering.html","title":"React: Use a Ternary Expression for Conditional Rendering","keywords":"","body":"React: Use a Ternary Expression for Conditional Rendering Before moving on to dynamic rendering techniques, there's one last way to use built-in JavaScript conditionals to render what you want: the ternary operator. The ternary operator is often utilized as a shortcut for if/else statements in JavaScript. They're not quite as robust as traditional if/else statements, but they are very popular among React developers. One reason for this is because of how JSX is compiled, if/else statements can't be inserted directly into JSX code. You might have noticed this a couple challenges ago — when an if/else statement was required, it was always outside the return statement. Ternary expressions can be an excellent alternative if you want to implement conditional logic within your JSX. Recall that a ternary operator has three parts, but you can combine several ternary expressions together. Here's the basic syntax: condition ? expressionIfTrue : expressionIfFalse The code editor has three constants defined within the CheckUserAge component's render() method. They are called buttonOne, buttonTwo, and buttonThree. Each of these is assigned a simple JSX expression representing a button element. First, initialize the state of CheckUserAge with input and userAge both set to values of an empty string. Once the component is rendering information to the page, users should have a way to interact with it. Within the component's return statement, set up a ternary expression that implements the following logic: when the page first loads, render the submit button, buttonOne, to the page. Then, when a user enters their age and clicks the button, render a different button based on the age. If a user enters a number less than 18, render buttonThree. If a user enters a number greater than or equal to 18, render buttonTwo. const inputStyle = { width: 235, margin: 5 } class CheckUserAge extends React.Component { constructor(props) { super(props); // change code below this line this.state={ input: '', userAge: '' } // change code above this line this.submit = this.submit.bind(this); this.handleChange = this.handleChange.bind(this); } handleChange(e) { this.setState({ input: e.target.value, userAge: '' }); } submit() { this.setState({ userAge: this.state.input }); } render() { const buttonOne = Submit; const buttonTwo = You May Enter; const buttonThree = You Shall Not Pass; return ( Enter Your Age to Continue { ''===this.state.userAge ? buttonOne : (this.state.userAge ); } }; "},"react-render-conditionally-from-props.html":{"url":"react-render-conditionally-from-props.html","title":"React: Render Conditionally from Props","keywords":"","body":"React: Render Conditionally from Props So far, you've seen how to use if/else, &&, null and the ternary operator (condition ? expressionIfTrue : expressionIfFalse) to make conditional decisions about what to render and when. However, there's one important topic left to discuss that lets you combine any or all of these concepts with another powerful React feature: props. Using props to conditionally render code is very common with React developers — that is, they use the value of a given prop to automatically make decisions about what to render. In this challenge, you'll set up a child component to make rendering decisions based on props. You'll also use the ternary operator, but you can see how several of the other concepts that were covered in the last few challenges might be just as useful in this context. The code editor has two components that are partially defined for you: a parent called GameOfChance, and a child called Results. They are used to create a simple game where the user presses a button to see if they win or lose. First, you'll need a simple expression that randomly returns a different value every time it is run. You can use Math.random(). This method returns a value between 0 (inclusive) and 1 (exclusive) each time it is called. So for 50/50 odds, use Math.random() > .5 in your expression. Statistically speaking, this expression will return true 50% of the time, and false the other 50%. On line 30, replace the comment with this expression to complete the variable declaration. Now you have an expression that you can use to make a randomized decision in the code. Next you need to implement this. Render the Results component as a child of GameOfChance, and pass in expression as a prop called fiftyFifty. In the Results component, write a ternary expression to render the text \"You win!\" or \"You lose!\" based on the fiftyFifty prop that's being passed in from GameOfChance. Finally, make sure the handleClick() method is correctly counting each turn so the user knows how many times they've played. This also serves to let the user know the component has actually updated in case they win or lose twice in a row. class Results extends React.Component { constructor(props) { super(props); } render() { return ( { this.props.fiftyFifty ? \"You win!\":\"You lose!\" /* change code here */ } ) }; }; class GameOfChance extends React.Component { constructor(props) { super(props); this.state = { counter: 1 } this.handleClick = this.handleClick.bind(this); } handleClick() { this.setState({ counter: ++this.state.counter // change code here }); } render() { let expression = Math.random() > .5; // change code here return ( Play Again { /* change code below this line */ } { /* change code above this line */ } {'Turn: ' + this.state.counter} ); } }; "},"react-change-inline-css-conditionally-based-on-component-state.html":{"url":"react-change-inline-css-conditionally-based-on-component-state.html","title":"React: Change Inline CSS Conditionally Based on Component State","keywords":"","body":"React: Change Inline CSS Conditionally Based on Component State At this point, you've seen several applications of conditional rendering and the use of inline styles. Here's one more example that combines both of these topics. You can also render CSS conditionally based on the state of a React component. To do this, you check for a condition, and if that condition is met, you modify the styles object that's assigned to the JSX elements in the render method. This paradigm is important to understand because it is a dramatic shift from the more traditional approach of applying styles by modifying DOM elements directly (which is very common with jQuery, for example). In that approach, you must keep track of when elements change and also handle the actual manipulation directly. It can become difficult to keep track of changes, potentially making your UI unpredictable. When you set a style object based on a condition, you describe how the UI should look as a function of the application's state. There is a clear flow of information that only moves in one direction. This is the preferred method when writing applications with React. The code editor has a simple controlled input component with a styled border. You want to style this border red if the user types more than 15 characters of text in the input box. Add a condition to check for this and, if the condition is valid, set the input border style to 3px solid red. You can try it out by entering text in the input. class GateKeeper extends React.Component { constructor(props) { super(props); this.state = { input: '' }; this.handleChange = this.handleChange.bind(this); } handleChange(event) { this.setState({ input: event.target.value }) } render() { let inputStyle = { border: '1px solid black' }; // change code below this line if(this.state.input.length>15){ inputStyle={ border: '3px solid red' } } // change code above this line return ( Don't Type Too Much: ); } }; "},"react-use-arraymap-to-dynamically-render-elements.html":{"url":"react-use-arraymap-to-dynamically-render-elements.html","title":"React: Use Array.map() to Dynamically Render Elements","keywords":"","body":"React: Use Array.map() to Dynamically Render Elements Conditional rendering is useful, but you may need your components to render an unknown number of elements. Often in reactive programming, a programmer has no way to know what the state of an application is until runtime, because so much depends on a user's interaction with that program. Programmers need to write their code to correctly handle that unknown state ahead of time. Using Array.map() in React illustrates this concept. For example, you create a simple \"To Do List\" app. As the programmer, you have no way of knowing how many items a user might have on their list. You need to set up your component to dynamically render the correct number of list elements long before someone using the program decides that today is laundry day. The code editor has most of the MyToDoList component set up. Some of this code should look familiar if you completed the controlled form challenge. You'll notice a textarea and a button, along with a couple of methods that track their states, but nothing is rendered to the page yet. Inside the constructor, create a this.state object and define two states: userInput should be initialized as an empty string, and toDoList should be initialized as an empty array. Next, delete the comment in the render() method next to the items variable. In its place, map over the toDoList array stored in the component's internal state and dynamically render a li for each item. Try entering the string eat, code, sleep, repeat into the textarea, then click the button and see what happens. Note: You may know that all sibling child elements created by a mapping operation like this do need to be supplied with a unique key attribute. Don't worry, this is the topic of the next challenge. const textAreaStyles = { width: 235, margin: 5 }; class MyToDoList extends React.Component { constructor(props) { super(props); // change code below this line this.state={ toDoList: [], userInput:\"\" } // change code above this line this.handleSubmit = this.handleSubmit.bind(this); this.handleChange = this.handleChange.bind(this); } handleSubmit() { const itemsArray = this.state.userInput.split(','); this.setState({ toDoList: itemsArray }); } handleChange(e) { this.setState({ userInput: e.target.value }); } render() { const items = this.state.toDoList.map((items) => ({items})); return ( Create List My \"To Do\" List: {items} ); } }; "},"react-give-sibling-elements-a-unique-key-attribute.html":{"url":"react-give-sibling-elements-a-unique-key-attribute.html","title":"React: Give Sibling Elements a Unique Key Attribute","keywords":"","body":"React: Give Sibling Elements a Unique Key Attribute The last challenge showed how the map method is used to dynamically render a number of elements based on user input. However, there was an important piece missing from that example. When you create an array of elements, each one needs a key attribute set to a unique value. React uses these keys to keep track of which items are added, changed, or removed. This helps make the re-rendering process more efficient when the list is modified in any way. Note that keys only need to be unique between sibling elements, they don't need to be globally unique in your application. The code editor has an array with some front end frameworks and a stateless functional component named Frameworks(). Frameworks() needs to map the array to an unordered list, much like in the last challenge. Finish writing the map callback to return an li element for each framework in the frontEndFrameworks array. This time, make sure to give each li a key attribute, set to a unique value. Normally, you want to make the key something that uniquely identifies the element being rendered. As a last resort the array index may be used, but typically you should try to use a unique identification. const frontEndFrameworks = [ 'React', 'Angular', 'Ember', 'Knockout', 'Backbone', 'Vue' ]; function Frameworks() { const renderFrameworks = frontEndFrameworks.map((item)=>({item})); // change code here return ( Popular Front End JavaScript Frameworks {renderFrameworks} ); }; "},"react-use-arrayfilter-to-dynamically-filter-an-array.html":{"url":"react-use-arrayfilter-to-dynamically-filter-an-array.html","title":"React: Use Array.filter() to Dynamically Filter an Array","keywords":"","body":"React: Use Array.filter() to Dynamically Filter an Array The map array method is a powerful tool that you will use often when working with React. Another method related to map is filter, which filters the contents of an array based on a condition, then returns a new array. For example, if you have an array of users that all have a property online which can be set to true or false, you can filter only those users that are online by writing: let onlineUsers = users.filter(user => user.online); In the code editor, MyComponent's state is initialized with an array of users. Some users are online and some aren't. Filter the array so you see only the users who are online. To do this, first use filter to return a new array containing only the users whose online property is true. Then, in the renderOnline variable, map over the filtered array, and return a li element for each user that contains the text of their username. Be sure to include a unique key as well, like in the last challenges. class MyComponent extends React.Component { constructor(props) { super(props); this.state = { users: [ { username: 'Jeff', online: true }, { username: 'Alan', online: false }, { username: 'Mary', online: true }, { username: 'Jim', online: false }, { username: 'Sara', online: true }, { username: 'Laura', online: true } ] } } render() { const usersOnline = this.state.users.filter((user)=>(user.online)); // change code here const renderOnline = usersOnline.map((user)=>({user.username})); // change code here return ( Current Online Users: {renderOnline} ); } }; "},"react-render-react-on-the-server-with-rendertostring.html":{"url":"react-render-react-on-the-server-with-rendertostring.html","title":"React: Render React on the Server with renderToString","keywords":"","body":"React: Render React on the Server with renderToString So far, you have been rendering React components on the client. Normally, this is what you will always do. However, there are some use cases where it makes sense to render a React component on the server. Since React is a JavaScript view library and you can run JavaScript on the server with Node, this is possible. In fact, React provides a renderToString() method you can use for this purpose. There are two key reasons why rendering on the server may be used in a real world app. First, without doing this, your React apps would consist of a relatively empty HTML file and a large bundle of JavaScript when it's initially loaded to the browser. This may not be ideal for search engines that are trying to index the content of your pages so people can find you. If you render the initial HTML markup on the server and send this to the client, the initial page load contains all of the page's markup which can be crawled by search engines. Second, this creates a faster initial page load experience because the rendered HTML is smaller than the JavaScript code of the entire app. React will still be able to recognize your app and manage it after the initial load. The renderToString() method is provided on ReactDOMServer, which is available here as a global object. The method takes one argument which is a React element. Use this to render App to a string. class App extends React.Component { constructor(props) { super(props); } render() { return } }; // change code below this line ReactDOMServer.renderToString(); "},"redux.html":{"url":"redux.html","title":"Redux","keywords":"","body":"Introduction to the Redux Challenges Redux is a predictable state container for JavaScript apps. It helps you write applications that behave consistently, run in different environments (client, server, and native), and are easy to test. While you can use Redux with any view library, it's introduced here before being combined with React. Improve this intro on GitHub. "},"redux/redux-create-a-redux-store.html":{"url":"redux/redux-create-a-redux-store.html","title":"Redux: Create a Redux Store","keywords":"","body":"Redux: Create a Redux Store Redux is a state management framework that can be used with a number of different web technologies, including React. In Redux, there is a single state object that's responsible for the entire state of your application. This means if you had a React app with ten components, and each component had its own local state, the entire state of your app would be defined by a single state object housed in the Redux store. This is the first important principle to understand when learning Redux: the Redux store is the single source of truth when it comes to application state. This also means that any time any piece of your app wants to update state, it must do so through the Redux store. The unidirectional data flow makes it easier to track state management in your app. The Redux store is an object which holds and manages application state. There is a method called createStore() on the Redux object, which you use to create the Redux store. This method takes a reducer function as a required argument. The reducer function is covered in a later challenge, and is already defined for you in the code editor. It simply takes state as an argument and returns state. Declare a store variable and assign it to the createStore() method, passing in the reducer as an argument. Note: The code in the editor uses ES6 default argument syntax to initialize this state to hold a value of 5. If you're not familiar with default arguments, you can refer to the ES6 section in the Curriculum which covers this topic. const reducer = (state = 5) => { return state; } // Redux methods are available from a Redux object // For example: Redux.createStore() // Define the store here: const store = Redux.createStore(reducer); "},"redux/redux-get-state-from-the-redux-store.html":{"url":"redux/redux-get-state-from-the-redux-store.html","title":"Redux: Get State from the Redux Store","keywords":"","body":"Redux: Get State from the Redux Store The Redux store object provides several methods that allow you to interact with it. For example, you can retrieve the current state held in the Redux store object with the getState() method. The code from the previous challenge is re-written more concisely in the code editor. Use store.getState() to retrieve the state from the store, and assign this to a new variable currentState. const store = Redux.createStore( (state = 5) => state ); // change code below this line let currentState = store.getState(); "},"redux/redux-define-a-redux-action.html":{"url":"redux/redux-define-a-redux-action.html","title":"Redux: Define a Redux Action","keywords":"","body":"Redux: Define a Redux Action Since Redux is a state management framework, updating state is one of its core tasks. In Redux, all state updates are triggered by dispatching actions. An action is simply a JavaScript object that contains information about an action event that has occurred. The Redux store receives these action objects, then updates its state accordingly. Sometimes a Redux action also carries some data. For example, the action carries a username after a user logs in. While the data is optional, actions must carry a type property that specifies the 'type' of action that occurred. Think of Redux actions as messengers that deliver information about events happening in your app to the Redux store. The store then conducts the business of updating state based on the action that occurred. Writing a Redux action is as simple as declaring an object with a type property. Declare an object action and give it a property type set to the string 'LOGIN'. // Define an action here: let action = {type: 'LOGIN'} "},"redux/redux-define-an-action-creator.html":{"url":"redux/redux-define-an-action-creator.html","title":"Redux: Define an Action Creator","keywords":"","body":"Redux: Define an Action Creator After creating an action, the next step is sending the action to the Redux store so it can update its state. In Redux, you define action creators to accomplish this. An action creator is simply a JavaScript function that returns an action. In other words, action creators create objects that represent action events. Define a function named actionCreator() that returns the action object when called. const action = { type: 'LOGIN' } // Define an action creator here: function actionCreator(){ return action; } "},"redux/redux-dispatch-an-action-event.html":{"url":"redux/redux-dispatch-an-action-event.html","title":"Redux: Dispatch an Action Event","keywords":"","body":"Redux: Dispatch an Action Event dispatch method is what you use to dispatch actions to the Redux store. Calling store.dispatch() and passing the value returned from an action creator sends an action back to the store. Recall that action creators return an object with a type property that specifies the action that has occurred. Then the method dispatches an action object to the Redux store. Based on the previous challenge's example, the following lines are equivalent, and both dispatch the action of type LOGIN: store.dispatch(actionCreator()); store.dispatch({ type: 'LOGIN' }); The Redux store in the code editor has an initialized state that's an object containing a login property currently set to false. There's also an action creator called loginAction() which returns an action of type LOGIN. Dispatch the LOGIN action to the Redux store by calling the dispatch method, and pass in the action created by loginAction(). const store = Redux.createStore( (state = {login: false}) => state ); const loginAction = () => { return { type: 'LOGIN' } }; // Dispatch the action here: store.dispatch(loginAction()); "},"redux/redux-handle-an-action-in-the-store.html":{"url":"redux/redux-handle-an-action-in-the-store.html","title":"Redux: Handle an Action in the Store","keywords":"","body":"Redux: Handle an Action in the Store After an action is created and dispatched, the Redux store needs to know how to respond to that action. This is the job of a reducer function. Reducers in Redux are responsible for the state modifications that take place in response to actions. A reducer takes state and action as arguments, and it always returns a new state. It is important to see that this is the only role of the reducer. It has no side effects — it never calls an API endpoint and it never has any hidden surprises. The reducer is simply a pure function that takes state and action, then returns new state. Another key principle in Redux is that state is read-only. In other words, the reducer function must always return a new copy of state and never modify state directly. Redux does not enforce state immutability, however, you are responsible for enforcing it in the code of your reducer functions. You'll practice this in later challenges. The code editor has the previous example as well as the start of a reducer function for you. Fill in the body of the reducer function so that if it receives an action of type 'LOGIN' it returns a state object with login set to true. Otherwise, it returns the current state. Note that the current state and the dispatched action are passed to the reducer, so you can access the action's type directly with action.type. const defaultState = { login: false }; const reducer = (state = defaultState, action) => { // change code below this line if(action.type === \"LOGIN\"){ return {login:true}; } return state; // change code above this line }; const store = Redux.createStore(reducer); const loginAction = () => { return { type: 'LOGIN' } }; "},"redux/redux-use-a-switch-statement-to-handle-multiple-actions.html":{"url":"redux/redux-use-a-switch-statement-to-handle-multiple-actions.html","title":"Redux: Use a Switch Statement to Handle Multiple Actions","keywords":"","body":"Redux: Use a Switch Statement to Handle Multiple Actions You can tell the Redux store how to handle multiple action types. Say you are managing user authentication in your Redux store. You want to have a state representation for when users are logged in and when they are logged out. You represent this with a single state object with the property authenticated. You also need action creators that create actions corresponding to user login and user logout, along with the action objects themselves. The code editor has a store, actions, and action creators set up for you. Fill in the reducer function to handle multiple authentication actions. Use a JavaScript switch statement in the reducer to respond to different action events. This is a standard pattern in writing Redux reducers. The switch statement should switch over action.type and return the appropriate authentication state. Note: At this point, don't worry about state immutability, since it is small and simple in this example. For each action, you can return a new object — for example, {authenticated: true}. Also, don't forget to write a default case in your switch statement that returns the current state. This is important because once your app has multiple reducers, they are all run any time an action dispatch is made, even when the action isn't related to that reducer. In such a case, you want to make sure that you return the current state. const defaultState = { authenticated: false }; const authReducer = (state = defaultState, action) => { // change code below this line switch(action.type){ case 'LOGIN': return {authenticated: true}; case 'LOGOUT': return {authenticated: false}; default: return state; } // change code above this line }; const store = Redux.createStore(authReducer); const loginUser = () => { return { type: 'LOGIN' } }; const logoutUser = () => { return { type: 'LOGOUT' } }; "},"redux/redux-use-const-for-action-types.html":{"url":"redux/redux-use-const-for-action-types.html","title":"Redux: Use const for Action Types","keywords":"","body":"Redux: Use const for Action Types A common practice when working with Redux is to assign action types as read-only constants, then reference these constants wherever they are used. You can refactor the code you're working with to write the action types as const declarations. Declare LOGIN and LOGOUT as const values and assign them to the strings 'LOGIN' and 'LOGOUT', respectively. Then, edit the authReducer() and the action creators to reference these constants instead of string values. Note: It's generally a convention to write constants in all uppercase, and this is standard practice in Redux as well. // change code below this line const LOGIN = 'LOGIN'; const LOGOUT = 'LOGOUT'; // change code above this line const defaultState = { authenticated: false }; const authReducer = (state = defaultState, action) => { switch (action.type) { case LOGIN: return { authenticated: true } case LOGOUT: return { authenticated: false } default: return state; } }; const store = Redux.createStore(authReducer); const loginUser = () => { return { type: LOGIN } }; const logoutUser = () => { return { type: LOGOUT } }; "},"redux/redux-register-a-store-listener.html":{"url":"redux/redux-register-a-store-listener.html","title":"Redux: Register a Store Listener","keywords":"","body":"Redux: Register a Store Listener Another method you have access to on the Redux store object is store.subscribe(). This allows you to subscribe listener functions to the store, which are called whenever an action is dispatched against the store. One simple use for this method is to subscribe a function to your store that simply logs a message every time an action is received and the store is updated. Write a callback function that increments the global variable count every time the store receives an action, and pass this function in to the store.subscribe() method. You'll see that store.dispatch() is called three times in a row, each time directly passing in an action object. Watch the console output between the action dispatches to see the updates take place. const ADD = 'ADD'; const reducer = (state = 0, action) => { switch(action.type) { case ADD: return state + 1; default: return state; } }; const store = Redux.createStore(reducer); // global count variable: let count = 0; // change code below this line store.subscribe(()=>count++); // change code above this line store.dispatch({type: ADD}); console.log(count); store.dispatch({type: ADD}); console.log(count); store.dispatch({type: ADD}); console.log(count); "},"redux/redux-combine-multiple-reducers.html":{"url":"redux/redux-combine-multiple-reducers.html","title":"Redux: Combine Multiple Reducers","keywords":"","body":"Redux: Combine Multiple Reducers When the state of your app begins to grow more complex, it may be tempting to divide state into multiple pieces. Instead, remember the first principle of Redux: all app state is held in a single state object in the store. Therefore, Redux provides reducer composition as a solution for a complex state model. You define multiple reducers to handle different pieces of your application's state, then compose these reducers together into one root reducer. The root reducer is then passed into the Redux createStore() method. In order to let us combine multiple reducers together, Redux provides the combineReducers() method. This method accepts an object as an argument in which you define properties which associate keys to specific reducer functions. The name you give to the keys will be used by Redux as the name for the associated piece of state. Typically, it is a good practice to create a reducer for each piece of application state when they are distinct or unique in some way. For example, in a note-taking app with user authentication, one reducer could handle authentication while another handles the text and notes that the user is submitting. For such an application, we might write the combineReducers() method like this: const rootReducer = Redux.combineReducers({ auth: authenticationReducer, notes: notesReducer }); Now, the key notes will contain all of the state associated with our notes and handled by our notesReducer. This is how multiple reducers can be composed to manage more complex application state. In this example, the state held in the Redux store would then be a single object containing auth and notes properties. There are counterReducer() and authReducer() functions provided in the code editor, along with a Redux store. Finish writing the rootReducer() function using the Redux.combineReducers() method. Assign counterReducer to a key called count and authReducer to a key called auth. const INCREMENT = 'INCREMENT'; const DECREMENT = 'DECREMENT'; const counterReducer = (state = 0, action) => { switch(action.type) { case INCREMENT: return state + 1; case DECREMENT: return state - 1; default: return state; } }; const LOGIN = 'LOGIN'; const LOGOUT = 'LOGOUT'; const authReducer = (state = {authenticated: false}, action) => { switch(action.type) { case LOGIN: return { authenticated: true } case LOGOUT: return { authenticated: false } default: return state; } }; const rootReducer = Redux.combineReducers({ auth: authReducer, count: counterReducer });// define the root reducer here const store = Redux.createStore(rootReducer); "},"redux/redux-send-action-data-to-the-store.html":{"url":"redux/redux-send-action-data-to-the-store.html","title":"Redux: Send Action Data to the Store","keywords":"","body":"Redux: Send Action Data to the Store By now you've learned how to dispatch actions to the Redux store, but so far these actions have not contained any information other than a type. You can also send specific data along with your actions. In fact, this is very common because actions usually originate from some user interaction and tend to carry some data with them. The Redux store often needs to know about this data. There's a basic notesReducer() and an addNoteText() action creator defined in the code editor. Finish the body of the addNoteText() function so that it returns an action object. The object should include a type property with a value of ADD_NOTE, and also a text property set to the note data that's passed into the action creator. When you call the action creator, you'll pass in specific note information that you can access for the object. Next, finish writing the switch statement in the notesReducer(). You need to add a case that handles the addNoteText() actions. This case should be triggered whenever there is an action of type ADD_NOTE and it should return the text property on the incoming action as the new state. The action is dispatched at the bottom of the code. Once you're finished, run the code and watch the console. That's all it takes to send action-specific data to the store and use it when you update store state. const ADD_NOTE = 'ADD_NOTE'; const notesReducer = (state = 'Initial State', action) => { switch(action.type) { // change code below this line case ADD_NOTE: return action.text; // change code above this line default: return state; } }; const addNoteText = (note) => { // change code below this line return { type: ADD_NOTE, text: note } // change code above this line }; const store = Redux.createStore(notesReducer); console.log(store.getState()); store.dispatch(addNoteText('Hello!')); console.log(store.getState()); "},"redux/redux-use-middleware-to-handle-asynchronous-actions.html":{"url":"redux/redux-use-middleware-to-handle-asynchronous-actions.html","title":"Redux: Use Middleware to Handle Asynchronous Actions","keywords":"","body":"Redux: Use Middleware to Handle Asynchronous Actions So far these challenges have avoided discussing asynchronous actions, but they are an unavoidable part of web development. At some point you'll need to call asynchronous endpoints in your Redux app, so how do you handle these types of requests? Redux provides middleware designed specifically for this purpose, called Redux Thunk middleware. Here's a brief description how to use this with Redux. To include Redux Thunk middleware, you pass it as an argument to Redux.applyMiddleware(). This statement is then provided as a second optional parameter to the createStore() function. Take a look at the code at the bottom of the editor to see this. Then, to create an asynchronous action, you return a function in the action creator that takes dispatch as an argument. Within this function, you can dispatch actions and perform asynchronous requests. In this example, an asynchronous request is simulated with a setTimeout() call. It's common to dispatch an action before initiating any asynchronous behavior so that your application state knows that some data is being requested (this state could display a loading icon, for instance). Then, once you receive the data, you dispatch another action which carries the data as a payload along with information that the action is completed. Remember that you're passing dispatch as a parameter to this special action creator. This is what you'll use to dispatch your actions, you simply pass the action directly to dispatch and the middleware takes care of the rest. Write both dispatches in the handleAsync() action creator. Dispatch requestingData() before the setTimeout() (the simulated API call). Then, after you receive the (pretend) data, dispatch the receivedData() action, passing in this data. Now you know how to handle asynchronous actions in Redux. Everything else continues to behave as before. const REQUESTING_DATA = 'REQUESTING_DATA' const RECEIVED_DATA = 'RECEIVED_DATA' const requestingData = () => { return {type: REQUESTING_DATA} } const receivedData = (data) => { return {type: RECEIVED_DATA, users: data.users} } const handleAsync = () => { return function(dispatch) { // dispatch request action here dispatch(requestingData()); setTimeout(function() { let data = { users: ['Jeff', 'William', 'Alice'] } // dispatch received data action here dispatch(receivedData(data)); }, 2500); } }; const defaultState = { fetching: false, users: [] }; const asyncDataReducer = (state = defaultState, action) => { switch(action.type) { case REQUESTING_DATA: return { fetching: true, users: [] } case RECEIVED_DATA: return { fetching: false, users: action.users } default: return state; } }; const store = Redux.createStore( asyncDataReducer, Redux.applyMiddleware(ReduxThunk.default) ); "},"redux/redux-write-a-counter-with-redux.html":{"url":"redux/redux-write-a-counter-with-redux.html","title":"Redux: Write a Counter with Redux","keywords":"","body":"Redux: Write a Counter with Redux Now you've learned all the core principles of Redux! You've seen how to create actions and action creators, create a Redux store, dispatch your actions against the store, and design state updates with pure reducers. You've even seen how to manage complex state with reducer composition and handle asynchronous actions. These examples are simplistic, but these concepts are the core principles of Redux. If you understand them well, you're ready to start building your own Redux app. The next challenges cover some of the details regarding state immutability, but first, here's a review of everything you've learned so far. In this lesson, you'll implement a simple counter with Redux from scratch. The basics are provided in the code editor, but you'll have to fill in the details! Use the names that are provided and define incAction and decAction action creators, the counterReducer(), INCREMENT and DECREMENT action types, and finally the Redux store. Once you're finished you should be able to dispatch INCREMENT or DECREMENT actions to increment or decrement the state held in the store. Good luck building your first Redux app! const INCREMENT = 'INCREMENT'; // define a constant for increment action types const DECREMENT = 'DECREMENT'; // define a constant for decrement action types const counterReducer = (state=0,action) => { switch(action.type){ case INCREMENT: state++; break; case DECREMENT: state--; break; default: break; } return state; }; // define the counter reducer which will increment or decrement the state based on the action it receives const incAction = () => ({type: INCREMENT}); // define an action creator for incrementing const decAction = () => ({type: DECREMENT}); // define an action creator for decrementing const store = Redux.createStore(counterReducer); // define the Redux store here, passing in your reducers "},"redux/redux-never-mutate-state.html":{"url":"redux/redux-never-mutate-state.html","title":"Redux: Never Mutate State","keywords":"","body":"Redux: Never Mutate State These final challenges describe several methods of enforcing the key principle of state immutability in Redux. Immutable state means that you never modify state directly, instead, you return a new copy of state. If you took a snapshot of the state of a Redux app over time, you would see something like state 1, state 2, state 3,state 4, ... and so on where each state may be similar to the last, but each is a distinct piece of data. This immutability, in fact, is what provides such features as time-travel debugging that you may have heard about. Redux does not actively enforce state immutability in its store or reducers, that responsibility falls on the programmer. Fortunately, JavaScript (especially ES6) provides several useful tools you can use to enforce the immutability of your state, whether it is a string, number, array, or object. Note that strings and numbers are primitive values and are immutable by nature. In other words, 3 is always 3. You cannot change the value of the number 3. An array or object, however, is mutable. In practice, your state will probably consist of an array or object, as these are useful data structures for representing many types of information. There is a store and reducer in the code editor for managing to-do items. Finish writing the ADD_TO_DO case in the reducer to append a new to-do to the state. There are a few ways to accomplish this with standard JavaScript or ES6. See if you can find a way to return a new array with the item from action.todo appended to the end. const ADD_TO_DO = 'ADD_TO_DO'; // A list of strings representing tasks to do: const todos = [ 'Go to the store', 'Clean the house', 'Cook dinner', 'Learn to code', ]; const immutableReducer = (state = todos, action) => { switch(action.type) { case ADD_TO_DO: // don't mutate state here or the tests will fail let arr = state.map(x => x); arr.push(action.todo); return arr; default: return state; } }; // an example todo argument would be 'Learn React', const addToDo = (todo) => { return { type: ADD_TO_DO, todo } } const store = Redux.createStore(immutableReducer); "},"redux/redux-use-the-spread-operator-on-arrays.html":{"url":"redux/redux-use-the-spread-operator-on-arrays.html","title":"Redux: Use the Spread Operator on Arrays","keywords":"","body":"Redux: Use the Spread Operator on Arrays One solution from ES6 to help enforce state immutability in Redux is the spread operator: .... The spread operator has a variety of applications, one of which is well-suited to the previous challenge of producing a new array from an existing array. This is relatively new, but commonly used syntax. For example, if you have an array myArray and write: let newArray = [...myArray]; newArray is now a clone of myArray. Both arrays still exist separately in memory. If you perform a mutation like newArray.push(5), myArray doesn't change. The ... effectively spreads out the values in myArray into a new array. To clone an array but add additional values in the new array, you could write [...myArray, 'new value']. This would return a new array composed of the values in myArray and the string 'new value' as the last value. The spread syntax can be used multiple times in array composition like this, but it's important to note that it only makes a shallow copy of the array. That is to say, it only provides immutable array operations for one-dimensional arrays. Use the spread operator to return a new copy of state when a to-do is added. const immutableReducer = (state = ['Do not mutate state!'], action) => { switch(action.type) { case 'ADD_TO_DO': let arr = [...state,action.todo] return arr; // don't mutate state here or the tests will fail return default: return state; } }; const addToDo = (todo) => { return { type: 'ADD_TO_DO', todo } } const store = Redux.createStore(immutableReducer); "},"redux/redux-remove-an-item-from-an-array.html":{"url":"redux/redux-remove-an-item-from-an-array.html","title":"Redux: Remove an Item from an Array","keywords":"","body":"Redux: Remove an Item from an Array Time to practice removing items from an array. The spread operator can be used here as well. Other useful JavaScript methods include slice() and concat(). The reducer and action creator were modified to remove an item from an array based on the index of the item. Finish writing the reducer so a new state array is returned with the item at the specific index removed. const immutableReducer = (state = [0,1,2,3,4,5], action) => { switch(action.type) { case 'REMOVE_ITEM': // don't mutate state here or the tests will fail let newState = [...state]; newState.splice(action.index, 1); return newState; default: return state; } }; const removeItem = (index) => { return { type: 'REMOVE_ITEM', index } } const store = Redux.createStore(immutableReducer); "},"redux/redux-copy-an-object-with-objectassign.html":{"url":"redux/redux-copy-an-object-with-objectassign.html","title":"Redux: Copy an Object with Object.assign","keywords":"","body":"Redux: Copy an Object with Object.assign The last several challenges worked with arrays, but there are ways to help enforce state immutability when state is an object, too. A useful tool for handling objects is the Object.assign() utility. Object.assign() takes a target object and source objects and maps properties from the source objects to the target object. Any matching properties are overwritten by properties in the source objects. This behavior is commonly used to make shallow copies of objects by passing an empty object as the first argument followed by the object(s) you want to copy. Here's an example: const newObject = Object.assign({}, obj1, obj2); This creates newObject as a new object, which contains the properties that currently exist in obj1 and obj2. The Redux state and actions were modified to handle an object for the state. Edit the code to return a new state object for actions with type ONLINE, which set the status property to the string online. Try to use Object.assign() to complete the challenge. const defaultState = { user: 'CamperBot', status: 'offline', friends: '732,982', community: 'freeCodeCamp' }; const immutableReducer = (state = defaultState, action) => { switch(action.type) { case 'ONLINE': // don't mutate state here or the tests will fail let newObject = Object.assign({},defaultState); newObject.status='online'; return newObject; default: return state; } }; const wakeUp = () => { return { type: 'ONLINE' } }; const store = Redux.createStore(immutableReducer); "},"react-and-redux.html":{"url":"react-and-redux.html","title":"React and Redux","keywords":"","body":"Introduction to the React and Redux Challenges This series of challenges introduces how to use Redux with React. In a React Redux app, you create a single Redux store that manages the state of your entire app. Your React components subscribe to only the pieces of data in the store that are relevant to their role. Then, you dispatch actions directly from React components, which then trigger store updates. "},"react-and-redux/getting-started-with-react-redux.html":{"url":"react-and-redux/getting-started-with-react-redux.html","title":"Getting Started with React Redux","keywords":"","body":"React and Redux: Getting Started with React Redux This series of challenges introduces how to use Redux with React. First, here's a review of some of the key principles of each technology. React is a view library that you provide with data, then it renders the view in an efficient, predictable way. Redux is a state management framework that you can use to simplify the management of your application's state. Typically, in a React Redux app, you create a single Redux store that manages the state of your entire app. Your React components subscribe to only the pieces of data in the store that are relevant to their role. Then, you dispatch actions directly from React components, which then trigger store updates. Although React components can manage their own state locally, when you have a complex app, it's generally better to keep the app state in a single location with Redux. There are exceptions when individual components may have local state specific only to them. Finally, because Redux is not designed to work with React out of the box, you need to use the react-redux package. It provides a way for you to pass Redux state and dispatch to your React components as props. Over the next few challenges, first, you'll create a simple React component which allows you to input new text messages. These are added to an array that's displayed in the view. This should be a nice review of what you learned in the React lessons. Next, you'll create a Redux store and actions that manage the state of the messages array. Finally, you'll use react-redux to connect the Redux store with your component, thereby extracting the local state into the Redux store. Start with a DisplayMessages component. Add a constructor to this component and initialize it with a state that has two properties: input, that's set to an empty string, and messages, that's set to an empty array. class DisplayMessages extends React.Component { // change code below this line constructor(props){ super(props); this.state = { input: '', messages:[] } } // change code above this line render() { return } }; "},"react-and-redux/react-and-redux-manage-state-locally-first.html":{"url":"react-and-redux/react-and-redux-manage-state-locally-first.html","title":"React and Redux: Manage State Locally First","keywords":"","body":"React and Redux: Manage State Locally First Here you'll finish creating the DisplayMessages component. First, in the render() method, have the component render an input element, button element, and ul element. When the input element changes, it should trigger a handleChange() method. Also, the input element should render the value of input that's in the component's state. The button element should trigger a submitMessage() method when it's clicked. Second, write these two methods. The handleChange() method should update the input with what the user is typing. The submitMessage() method should concatenate the current message (stored in input) to the messages array in local state, and clear the value of the input. Finally, use the ul to map over the array of messages and render it to the screen as a list of li elements. class DisplayMessages extends React.Component { constructor(props) { super(props); this.state = { input: '', messages: [] } this.handleChange = this.handleChange.bind(this) this.submitMessage = this.submitMessage.bind(this) } // add handleChange() and submitMessage() methods here handleChange(event){ this.setState({ input:event.target.value }) } submitMessage(){ let intputVal = this.state.input; let arr = [...this.state.messages,intputVal]; this.setState({ input:'', messages:arr }) } render() { const items = this.state.messages.map((items) => ({items})); return ( Type in a new Message: { /* render an input, button, and ul here */ } submit {items} { /* change code above this line */ } ); } }; "},"react-and-redux/react-and-redux-extract-state-logic-to-redux.html":{"url":"react-and-redux/react-and-redux-extract-state-logic-to-redux.html","title":"React and Redux: Extract State Logic to Redux","keywords":"","body":"React and Redux: Extract State Logic to Redux Now that you finished the React component, you need to move the logic it's performing locally in its state into Redux. This is the first step to connect the simple React app to Redux. The only functionality your app has is to add new messages from the user to an unordered list. The example is simple in order to demonstrate how React and Redux work together. First, define an action type 'ADD' and set it to a const ADD. Next, define an action creator addMessage() which creates the action to add a message. You'll need to pass a message to this action creator and include the message in the returned action. Then create a reducer called messageReducer() that handles the state for the messages. The initial state should equal an empty array. This reducer should add a message to the array of messages held in state, or return the current state. Finally, create your Redux store and pass it the reducer. // define ADD, addMessage(), messageReducer(), and store here: const ADD = 'ADD' let addMessage =(msg)=> { return { type: ADD, message: msg }; } let messageReducer =(state = [],action) =>{ switch(action.type){ case ADD: return [...state,action.message]; default: return state; } } let store = Redux.createStore(messageReducer); "},"react-and-redux/react-and-redux-use-provider-to-connect-redux-to-react.html":{"url":"react-and-redux/react-and-redux-use-provider-to-connect-redux-to-react.html","title":"React and Redux: Use Provider to Connect Redux to React","keywords":"","body":"React and Redux: Use Provider to Connect Redux to React In the last challenge, you created a Redux store to handle the messages array and created an action for adding new messages. The next step is to provide React access to the Redux store and the actions it needs to dispatch updates. React Redux provides its react-redux package to help accomplish these tasks. React Redux provides a small API with two key features: Provider and connect. Another challenge covers connect. The Provider is a wrapper component from React Redux that wraps your React app. This wrapper then allows you to access the Redux store and dispatch functions throughout your component tree. Provider takes two props, the Redux store and the child components of your app. Defining the Provider for an App component might look like this: The code editor now shows all your Redux and React code from the past several challenges. It includes the Redux store, actions, and the DisplayMessages component. The only new piece is the AppWrapper component at the bottom. Use this top level component to render the Provider from ReactRedux, and pass the Redux store as a prop. Then render the DisplayMessages component as a child. Once you are finished, you should see your React component rendered to the page. Note: React Redux is available as a global variable here, so you can access the Provider with dot notation. The code in the editor takes advantage of this and sets it to a constant Provider for you to use in the AppWrapper render method. // Redux Code: const ADD = 'ADD'; const addMessage = (message) => { return { type: ADD, message } }; const messageReducer = (state = [], action) => { switch (action.type) { case ADD: return [ ...state, action.message ]; default: return state; } }; const store = Redux.createStore(messageReducer); // React Code: class DisplayMessages extends React.Component { constructor(props) { super(props); this.state = { input: '', messages: [] } this.handleChange = this.handleChange.bind(this); this.submitMessage = this.submitMessage.bind(this); } handleChange(event) { this.setState({ input: event.target.value }); } submitMessage() { const currentMessage = this.state.input; this.setState({ input: '', messages: this.state.messages.concat(currentMessage) }); } render() { return ( Type in a new Message: Submit {this.state.messages.map( (message, idx) => { return ( {message} ) }) } ); } }; const Provider = ReactRedux.Provider; class AppWrapper extends React.Component { // render the Provider here render(){ return( ) } // change code above this line }; "},"react-and-redux/react-and-redux-map-state-to-props.html":{"url":"react-and-redux/react-and-redux-map-state-to-props.html","title":"React and Redux: Map State to Props","keywords":"","body":"React and Redux: Map State to Props The Provider component allows you to provide state and dispatch to your React components, but you must specify exactly what state and actions you want. This way, you make sure that each component only has access to the state it needs. You accomplish this by creating two functions: mapStateToProps() and mapDispatchToProps(). In these functions, you declare what pieces of state you want to have access to and which action creators you need to be able to dispatch. Once these functions are in place, you'll see how to use the React Redux connect method to connect them to your components in another challenge. Note: Behind the scenes, React Redux uses the store.subscribe() method to implement mapStateToProps(). Create a function mapStateToProps(). This function should take state as an argument, then return an object which maps that state to specific property names. These properties will become accessible to your component via props. Since this example keeps the entire state of the app in a single array, you can pass that entire state to your component. Create a property messages in the object that's being returned, and set it to state. const state = []; // change code below this line let mapStateToProps = (state) =>{ return{ messages: state } } "},"react-and-redux/react-and-redux-map-dispatch-to-props.html":{"url":"react-and-redux/react-and-redux-map-dispatch-to-props.html","title":"React and Redux: Map Dispatch to Props","keywords":"","body":"React and Redux: Map Dispatch to Props The mapDispatchToProps() function is used to provide specific action creators to your React components so they can dispatch actions against the Redux store. It's similar in structure to the mapStateToProps() function you wrote in the last challenge. It returns an object that maps dispatch actions to property names, which become component props. However, instead of returning a piece of state, each property returns a function that calls dispatch with an action creator and any relevant action data. You have access to this dispatch because it's passed in to mapDispatchToProps() as a parameter when you define the function, just like you passed state to mapStateToProps(). Behind the scenes, React Redux is using Redux's store.dispatch() to conduct these dispatches with mapDispatchToProps(). This is similar to how it uses store.subscribe() for components that are mapped to state. For example, you have a loginUser() action creator that takes a username as an action payload. The object returned from mapDispatchToProps() for this action creator would look something like: { submitLoginUser: function(username) { dispatch(loginUser(username)); } } The code editor provides an action creator called addMessage(). Write the function mapDispatchToProps() that takes dispatch as an argument, then returns an object. The object should have a property submitNewMessage set to the dispatch function, which takes a parameter for the new message to add when it dispatches addMessage(). const addMessage = (message) => { return { type: 'ADD', message: message } }; // change code below this line function mapDispatchToProps(dispatch) { return{ submitNewMessage: function(message){ dispatch(addMessage(message)) } } } "},"react-and-redux/react-and-redux-connect-redux-to-react.html":{"url":"react-and-redux/react-and-redux-connect-redux-to-react.html","title":"React and Redux: Connect Redux to React","keywords":"","body":"React and Redux: Connect Redux to React Now that you've written both the mapStateToProps() and the mapDispatchToProps() functions, you can use them to map state and dispatch to the props of one of your React components. The connect method from React Redux can handle this task. This method takes two optional arguments, mapStateToProps() and mapDispatchToProps(). They are optional because you may have a component that only needs access to state but doesn't need to dispatch any actions, or vice versa. To use this method, pass in the functions as arguments, and immediately call the result with your component. This syntax is a little unusual and looks like: connect(mapStateToProps, mapDispatchToProps)(MyComponent) Note: If you want to omit one of the arguments to the connect method, you pass null in its place. The code editor has the mapStateToProps() and mapDispatchToProps() functions and a new React component called Presentational. Connect this component to Redux with the connect method from the ReactRedux global object, and call it immediately on the Presentational component. Assign the result to a new const called ConnectedComponent that represents the connected component. That's it, now you're connected to Redux! Try changing either of connect's arguments to null and observe the test results. const addMessage = (message) => { return { type: 'ADD', message: message } }; const mapStateToProps = (state) => { return { messages: state } }; const mapDispatchToProps = (dispatch) => { return { submitNewMessage: (message) => { dispatch(addMessage(message)); } } }; class Presentational extends React.Component { constructor(props) { super(props); } render() { return This is a Presentational Component } }; const connect = ReactRedux.connect; // change code below this line const ConnectedComponent = connect(mapStateToProps,mapDispatchToProps)(Presentational); "},"react-and-redux/react-and-redux-connect-redux-to-the-messages-app.html":{"url":"react-and-redux/react-and-redux-connect-redux-to-the-messages-app.html","title":"React and Redux: Connect Redux to the Messages App","keywords":"","body":"React and Redux: Connect Redux to the Messages App Now that you understand how to use connect to connect React to Redux, you can apply what you've learned to your React component that handles messages. In the last lesson, the component you connected to Redux was named Presentational, and this wasn't arbitrary. This term generally refers to React components that are not directly connected to Redux. They are simply responsible for the presentation of UI and do this as a function of the props they receive. By contrast, container components are connected to Redux. These are typically responsible for dispatching actions to the store and often pass store state to child components as props. The code editor has all the code you've written in this section so far. The only change is that the React component is renamed to Presentational. Create a new component held in a constant called Container that uses connect to connect the Presentational component to Redux. Then, in the AppWrapper, render the React Redux Provider component. Pass Provider the Redux store as a prop and render Container as a child. Once everything is setup, you will see the messages app rendered to the page again. // Redux: const ADD = 'ADD'; const addMessage = (message) => { return { type: ADD, message: message } }; const messageReducer = (state = [], action) => { switch (action.type) { case ADD: return [ ...state, action.message ]; default: return state; } }; const store = Redux.createStore(messageReducer); // React: class Presentational extends React.Component { constructor(props) { super(props); this.state = { input: '', messages: [] } this.handleChange = this.handleChange.bind(this); this.submitMessage = this.submitMessage.bind(this); } handleChange(event) { this.setState({ input: event.target.value }); } submitMessage() { const currentMessage = this.state.input; this.setState({ input: '', messages: this.state.messages.concat(currentMessage) }); } render() { return ( Type in a new Message: Submit {this.state.messages.map( (message, idx) => { return ( {message} ) }) } ); } }; // React-Redux: const mapStateToProps = (state) => { return { messages: state } }; const mapDispatchToProps = (dispatch) => { return { submitNewMessage: (newMessage) => { dispatch(addMessage(newMessage)) } } }; const Provider = ReactRedux.Provider; const connect = ReactRedux.connect; // define the Container component here: const Container = connect(mapStateToProps,mapDispatchToProps)(Presentational); class AppWrapper extends React.Component { constructor(props) { super(props); } render() { // complete the return statement: return ( ); } }; "},"react-and-redux/react-and-redux-extract-local-state-into-redux.html":{"url":"react-and-redux/react-and-redux-extract-local-state-into-redux.html","title":"React and Redux: Extract Local State into Redux","keywords":"","body":"React and Redux: Extract Local State into Redux You're almost done! Recall that you wrote all the Redux code so that Redux could control the state management of your React messages app. Now that Redux is connected, you need to extract the state management out of the Presentational component and into Redux. Currently, you have Redux connected, but you are handling the state locally within the Presentational component. In the Presentational component, first, remove the messages property in the local state. These messages will be managed by Redux. Next, modify the submitMessage() method so that it dispatches submitNewMessage() from this.props, and pass in the current message input from local state as an argument. Because you removed messages from local state, remove the messages property from the call to this.setState() here as well. Finally, modify the render() method so that it maps over the messages received from props rather than state. Once these changes are made, the app will continue to function the same, except Redux manages the state. This example also illustrates how a component may have local state: your component still tracks user input locally in its own state. You can see how Redux provides a useful state management framework on top of React. You achieved the same result using only React's local state at first, and this is usually possible with simple apps. However, as your apps become larger and more complex, so does your state management, and this is the problem Redux solves. // Redux: const ADD = 'ADD'; const addMessage = (message) => { return { type: ADD, message: message } }; const messageReducer = (state = [], action) => { switch (action.type) { case ADD: return [ ...state, action.message ]; default: return state; } }; const store = Redux.createStore(messageReducer); // React: const Provider = ReactRedux.Provider; const connect = ReactRedux.connect; // Change code below this line class Presentational extends React.Component { constructor(props) { super(props); this.state = { input: '', } this.handleChange = this.handleChange.bind(this); this.submitMessage = this.submitMessage.bind(this); } handleChange(event) { this.setState({ input: event.target.value }); } submitMessage() { this.props.submitNewMessage(this.state.input) this.setState({ input: '' }); } render() { return ( Type in a new Message: Submit {this.props.messages.map( (message, idx) => { return ( {message} ) }) } ); } }; // Change code above this line const mapStateToProps = (state) => { return {messages: state} }; const mapDispatchToProps = (dispatch) => { return { submitNewMessage: (message) => { dispatch(addMessage(message)) } } }; const Container = connect(mapStateToProps, mapDispatchToProps)(Presentational); class AppWrapper extends React.Component { render() { return ( ); } }; "},"react-and-redux/react-and-redux-moving-forward-from-here.html":{"url":"react-and-redux/react-and-redux-moving-forward-from-here.html","title":"React and Redux: Moving Forward From Here","keywords":"","body":"React and Redux: Moving Forward From Here Congratulations! You finished the lessons on React and Redux. There's one last item worth pointing out before you move on. Typically, you won't write React apps in a code editor like this. This challenge gives you a glimpse of what the syntax looks like if you're working with npm and a file system on your own machine. The code should look similar, except for the use of import statements (these pull in all of the dependencies that have been provided for you in the challenges). The \"Managing Packages with npm\" section covers npm in more detail. Finally, writing React and Redux code generally requires some configuration. This can get complicated quickly. If you are interested in experimenting on your own machine, the Create React App comes configured and ready to go. Alternatively, you can enable Babel as a JavaScript Preprocessor in CodePen, add React and ReactDOM as external JavaScript resources, and work there as well. Log the message 'Now I know React and Redux!' to the console. // import React from 'react' // import ReactDOM from 'react-dom' // import { Provider, connect } from 'react-redux' // import { createStore, combineReducers, applyMiddleware } from 'redux' // import thunk from 'redux-thunk' // import rootReducer from './redux/reducers' // import App from './components/App' // const store = createStore( // rootReducer, // applyMiddleware(thunk) // ); // ReactDOM.render( // // // , // document.getElementById('root') // ); // change code below this line console.log('Now I know React and Redux!') "},"data-visualization-certification/data-visualization-with-d3.html":{"url":"data-visualization-certification/data-visualization-with-d3.html","title":"Data Visualization with D3","keywords":"","body":"Introduction to the Data Visualization with D3 Challenges D3.js, or D3, stands for Data Driven Documents. D3 is a JavaScript library to create dynamic and interactive data visualizations in the browser. It's built to work with common web standards, namely HTML, CSS, and Scalable Vector Graphics (SVG). D3 takes input data and maps it into a visual representation of that data. It supports many different data formats. D3 lets you bind (or attach) the data to the Document Object Model (DOM). You use HTML or SVG elements with D3's built-in methods to transform the data into a visualization. D3 gives you a lot of control over the presentation of data. This section covers the basic functionality and how to create visualizations with the D3 library. "},"data-visualization-certification/data-visualization-with-d3/data-visualization-with-d3-add-document-elements-with-d3.html":{"url":"data-visualization-certification/data-visualization-with-d3/data-visualization-with-d3-add-document-elements-with-d3.html","title":"Data Visualization with D3: Add Document Elements with D3","keywords":"","body":"Data Visualization with D3: Add Document Elements with D3 D3 has several methods that let you add and change elements in your document. The select() method selects one element from the document. It takes an argument for the name of the element you want and returns an HTML node for the first element in the document that matches the name. Here's an example: const anchor = d3.select(\"a\"); The above example finds the first anchor tag on the page and saves an HTML node for it in the variable anchor. You can use the selection with other methods. The \"d3\" part of the example is a reference to the D3 object, which is how you access D3 methods. Two other useful methods are append() and text(). The append() method takes an argument for the element you want to add to the document. It appends an HTML node to a selected item, and returns a handle to that node. The text() method either sets the text of the selected node, or gets the current text. To set the value, you pass a string as an argument inside the parentheses of the method. Here's an example that selects an unordered list, appends a list item, and adds text: d3.select(\"ul\") .append(\"li\") .text(\"Very important item\"); D3 allows you to chain several methods together with periods to perform a number of actions in a row. Use the select method to select the body tag in the document. Then append an h1 tag to it, and add the text \"Learning D3\" into the h1 element. // Add your code below this line d3.select(\"body\").append(\"h1\").text(\"Learning D3\"); // Add your code above this line "},"data-visualization-certification/data-visualization-with-d3/data-visualization-with-d3-select-a-group-of-elements-with-d3.html":{"url":"data-visualization-certification/data-visualization-with-d3/data-visualization-with-d3-select-a-group-of-elements-with-d3.html","title":"Data Visualization with D3: Select a Group of Elements with D3","keywords":"","body":"Data Visualization with D3: Select a Group of Elements with D3 D3 also has the selectAll() method to select a group of elements. It returns an array of HTML nodes for all the items in the document that match the input string. Here's an example to select all the anchor tags in a document: const anchors = d3.selectAll(\"a\"); Like the select() method, selectAll() supports method chaining, and you can use it with other methods. Select all of the li tags in the document, and change their text to \"list item\" by chaining the .text() method. Example Example Example // Add your code below this line d3.selectAll(\"li\").text(\"list item\"); // Add your code above this line "},"data-visualization-certification/data-visualization-with-d3/data-visualization-with-d3-work-with-data-in-d3.html":{"url":"data-visualization-certification/data-visualization-with-d3/data-visualization-with-d3-work-with-data-in-d3.html","title":"Data Visualization with D3: Work with Data in D3","keywords":"","body":"Data Visualization with D3: Work with Data in D3 The D3 library focuses on a data-driven approach. When you have a set of data, you can apply D3 methods to display it on the page. Data comes in many formats, but this challenge uses a simple array of numbers. The first step is to make D3 aware of the data. The data() method is used on a selection of DOM elements to attach the data to those elements. The data set is passed as an argument to the method. A common workflow pattern is to create a new element in the document for each piece of data in the set. D3 has the enter() method for this purpose. When enter() is combined with the data() method, it looks at the selected elements from the page and compares them to the number of data items in the set. If there are fewer elements than data items, it creates the missing elements. Here is an example that selects a ul element and creates a new list item based on the number of entries in the array: const dataset = [\"a\", \"b\", \"c\"]; d3.select(\"ul\").selectAll(\"li\") .data(dataset) .enter() .append(\"li\") .text(\"New item\"); It may seem confusing to select elements that don't exist yet. This code is telling D3 to first select the ul on the page. Next, select all list items, which returns an empty selection. Then the data() method reviews the dataset and runs the following code three times, once for each item in the array. The enter() method sees there are no li elements on the page, but it needs 3 (one for each piece of data in dataset). New li elements are appended to the ul and have the text \"New item\". Select the body node, then select all h2 elements. Have D3 create and append an h2 tag for each item in the dataset array. The text in the h2 should say \"New Title\". Your code should use the data() and enter() methods. const dataset = [12, 31, 22, 17, 25, 18, 29, 14, 9]; // Add your code below this line d3.select(\"body\") .selectAll(\"h2\") .data(dataset) .enter() .append(\"h2\") .text(\"New Title\"); // Add your code above this line "},"data-visualization-certification/data-visualization-with-d3/data-visualization-with-d3-work-with-dynamic-data-in-d3.html":{"url":"data-visualization-certification/data-visualization-with-d3/data-visualization-with-d3-work-with-dynamic-data-in-d3.html","title":"Data Visualization with D3: Work with Dynamic Data in D3","keywords":"","body":"Data Visualization with D3: Work with Dynamic Data in D3 The last two challenges cover the basics of displaying data dynamically with D3 using the data() and enter() methods. These methods take a data set and, together with the append() method, create a new DOM element for each entry in the data set. In the previous challenge, you created a new h2 element for each item in the dataset array, but they all contained the same text, \"New Title\". This is because you have not made use of the data that is bound to each of the h2 elements. The D3 text() method can take a string or a callback function as an argument: selection.text((d) => d) In the example above, the parameter d refers to a single entry in the dataset that a selection is bound to. Using the current example as context, the first h2 element is bound to 12, the second h2 element is bound to 31, the third h2 element is bound to 22, and so on. Change the text() method so that each h2 element displays the corresponding value from the dataset array with a single space and \"USD\". For example, the first heading should be \"12 USD\". const dataset = [12, 31, 22, 17, 25, 18, 29, 14, 9]; d3.select(\"body\").selectAll(\"h2\") .data(dataset) .enter() .append(\"h2\") // Add your code below this line .text((data)=>data+\" USD\"); // Add your code above this line "},"data-visualization-certification/data-visualization-with-d3/data-visualization-with-d3-add-inline-styling-to-elements.html":{"url":"data-visualization-certification/data-visualization-with-d3/data-visualization-with-d3-add-inline-styling-to-elements.html","title":"Data Visualization with D3: Add Inline Styling to Elements","keywords":"","body":"Data Visualization with D3: Add Inline Styling to Elements D3 lets you add inline CSS styles on dynamic elements with the style() method. The style() method takes a comma-separated key-value pair as an argument. Here's an example to set the selection's text color to blue: selection.style(\"color\",\"blue\"); Add the style() method to the code in the editor to make all the displayed text have a font-family of verdana. const dataset = [12, 31, 22, 17, 25, 18, 29, 14, 9]; d3.select(\"body\").selectAll(\"h2\") .data(dataset) .enter() .append(\"h2\") .text((d) => (d + \" USD\")) // Add your code below this line .style(\"font-family\",\"verdana\"); // Add your code above this line "},"data-visualization-certification/data-visualization-with-d3/data-visualization-with-d3-change-styles-based-on-data.html":{"url":"data-visualization-certification/data-visualization-with-d3/data-visualization-with-d3-change-styles-based-on-data.html","title":"Data Visualization with D3: Change Styles Based on Data","keywords":"","body":"Data Visualization with D3: Change Styles Based on Data D3 is about visualization and presentation of data. It's likely you'll want to change the styling of elements based on the data. You can use a callback function in the style() method to change the styling for different elements. For example, you may want to color a data point blue if has a value less than 20, and red otherwise. You can use a callback function in the style() method and include the conditional logic. The callback function uses the d parameter to represent the data point: selection.style(\"color\", (d) => { / Logic that returns the color based on a condition / }); The style() method is not limited to setting the color - it can be used with other CSS properties as well. Add the style() method to the code in the editor to set the color of the h2 elements conditionally. Write the callback function so if the data value is less than 20, it returns \"red\", otherwise it returns \"green\". Note You can use if-else logic, or the ternary operator. const dataset = [12, 31, 22, 17, 25, 18, 29, 14, 9]; d3.select(\"body\").selectAll(\"h2\") .data(dataset) .enter() .append(\"h2\") .text((d) => (d + \" USD\")) // Add your code below this line .style(\"color\",(data)=>{ return data "},"data-visualization-certification/data-visualization-with-d3/data-visualization-with-d3-add-classes-with-d3.html":{"url":"data-visualization-certification/data-visualization-with-d3/data-visualization-with-d3-add-classes-with-d3.html","title":"Data Visualization with D3: Add Classes with D3","keywords":"","body":"Data Visualization with D3: Add Classes with D3 Using a lot of inline styles on HTML elements gets hard to manage, even for smaller apps. It's easier to add a class to elements and style that class one time using CSS rules. D3 has the attr() method to add any HTML attribute to an element, including a class name. The attr() method works the same way that style() does. It takes comma-separated values, and can use a callback function. Here's an example to add a class of \"container\" to a selection: selection.attr(\"class\", \"container\"); Add the attr() method to the code in the editor and put a class of bar on the div elements. .bar { width: 25px; height: 100px; display: inline-block; background-color: blue; } const dataset = [12, 31, 22, 17, 25, 18, 29, 14, 9]; d3.select(\"body\").selectAll(\"div\") .data(dataset) .enter() .append(\"div\") // Add your code below this line .attr(\"class\",\"bar\") // Add your code above this line "},"data-visualization-certification/data-visualization-with-d3/data-visualization-with-d3-update-the-height-of-an-element-dynamically.html":{"url":"data-visualization-certification/data-visualization-with-d3/data-visualization-with-d3-update-the-height-of-an-element-dynamically.html","title":"Data Visualization with D3: Update the Height of an Element Dynamically","keywords":"","body":"Data Visualization with D3: Update the Height of an Element Dynamically The previous challenges covered how to display data from an array and how to add CSS classes. You can combine these lessons to create a simple bar chart. There are two steps to this: 1) Create a div for each data point in the array 2) Give each div a dynamic height, using a callback function in the style() method that sets height equal to the data value Recall the format to set a style using a callback function: selection.style(\"cssProperty\", (d) => d) Add the style() method to the code in the editor to set the height property for each element. Use a callback function to return the value of the data point with the string \"px\" added to it. .bar { width: 25px; height: 100px; display: inline-block; background-color: blue; } const dataset = [12, 31, 22, 17, 25, 18, 29, 14, 9]; d3.select(\"body\").selectAll(\"div\") .data(dataset) .enter() .append(\"div\") .attr(\"class\", \"bar\") // Add your code below this line .style(\"height\",(data)=>{ return data+\"px\"; }) // Add your code above this line "},"data-visualization-certification/data-visualization-with-d3/data-visualization-with-d3-change-the-presentation-of-a-bar-chart.html":{"url":"data-visualization-certification/data-visualization-with-d3/data-visualization-with-d3-change-the-presentation-of-a-bar-chart.html","title":"Data Visualization with D3: Change the Presentation of a Bar Chart","keywords":"","body":"Data Visualization with D3: Change the Presentation of a Bar Chart The last challenge created a bar chart, but there are a couple of formatting changes that could improve it: 1) Add space between each bar to visually separate them, which is done by adding a margin to the CSS for the bar class 2) Increase the height of the bars to better show the difference in values, which is done by multiplying the value by a number to scale the height First, add a margin of 2px to the bar class in the style tag. Next, change the callback function in the style() method so it returns a value 10 times the original data value (plus the \"px\"). Note Multiplying each data point by the same constant only alters the scale. It's like zooming in, and it doesn't change the meaning of the underlying data. .bar { width: 25px; height: 100px; /* Add your code below this line */ margin: 2px; /* Add your code above this line */ display: inline-block; background-color: blue; } const dataset = [12, 31, 22, 17, 25, 18, 29, 14, 9]; d3.select(\"body\").selectAll(\"div\") .data(dataset) .enter() .append(\"div\") .attr(\"class\", \"bar\") // Add your code below this line .style(\"height\", (d) => (d*10 + \"px\")) // Add your code above this line "},"data-visualization-certification/data-visualization-with-d3/data-visualization-with-d3-learn-about-svg-in-d3.html":{"url":"data-visualization-certification/data-visualization-with-d3/data-visualization-with-d3-learn-about-svg-in-d3.html","title":"Data Visualization with D3: Learn About SVG in D3","keywords":"","body":"Data Visualization with D3: Learn About SVG in D3 SVG stands for Scalable Vector Graphics. Here \"scalable\" means that, if you zoom in or out on an object, it would not appear pixelated. It scales with the display system, whether it's on a small mobile screen or a large TV monitor. SVG is used to make common geometric shapes. Since D3 maps data into a visual representation, it uses SVG to create the shapes for the visualization. SVG shapes for a web page must go within an HTML svg tag. CSS can be scalable when styles use relative units (such as vh, vw, or percentages), but using SVG is more flexible to build data visualizations. Add an svg node to the body using append(). Give it a width attribute set to the provided w constant and a height attribute set to the provided h constant using the attr() method for each. You'll see it in the output because there's a background-color of pink applied to it in the style tag. Note Width and height attributes do not have units. This is the building block of scaling - the element will always have a 5:1 width to height ratio, no matter what the zoom level is. svg { background-color: pink; } const dataset = [12, 31, 22, 17, 25, 18, 29, 14, 9]; const w = 500; const h = 100; const svg = d3.select(\"body\") // Add your code below this line .append(\"svg\") .attr(\"width\",w) .attr(\"height\",h) // Add your code above this line "},"data-visualization-certification/data-visualization-with-d3/data-visualization-with-d3-display-shapes-with-svg.html":{"url":"data-visualization-certification/data-visualization-with-d3/data-visualization-with-d3-display-shapes-with-svg.html","title":"Data Visualization with D3: Display Shapes with SVG","keywords":"","body":"Data Visualization with D3: Display Shapes with SVG The last challenge created an svg element with a given width and height, which was visible because it had a background-color applied to it in the style tag. The code made space for the given width and height. The next step is to create a shape to put in the svg area. There are a number of supported shapes in SVG, such as rectangles and circles. They are used to display data. For example, a rectangle () SVG shape could create a bar in a bar chart. When you place a shape into the svg area, you can specify where it goes with x and y coordinates. The origin point of (0, 0) is in the upper-left corner. Positive values for x push the shape to the right, and positive values for y push the shape down from the origin point. To place a shape in the middle of the 500 (width) x 100 (height) svg from last challenge, the x coordinate would be 250 and the y coordinate would be 50. An SVG rect has four attributes. There are the x and y coordinates for where it is placed in the svg area. It also has a height and width to specify the size. Add a rect shape to the svg using append(), and give it a width attribute of 25 and height attribute of 100. Also, give the rect x and y attributes each set to 0. const dataset = [12, 31, 22, 17, 25, 18, 29, 14, 9]; const w = 500; const h = 100; const svg = d3.select(\"body\") .append(\"svg\") .attr(\"width\", w) .attr(\"height\", h) // Add your code below this line .append(\"rect\") .attr(\"width\",25) .attr(\"height\",100) .attr(\"x\",0) .attr(\"y\",0); // Add your code above this line "},"data-visualization-certification/data-visualization-with-d3/data-visualization-with-d3-create-a-bar-for-each-data-point-in-the-set.html":{"url":"data-visualization-certification/data-visualization-with-d3/data-visualization-with-d3-create-a-bar-for-each-data-point-in-the-set.html","title":"Data Visualization with D3: Create a Bar for Each Data Point in the Set","keywords":"","body":"Data Visualization with D3: Create a Bar for Each Data Point in the Set The last challenge added only one rectangle to the svg element to represent a bar. Here, you'll combine what you've learned so far about data(), enter(), and SVG shapes to create and append a rectangle for each data point in dataset. A previous challenge showed the format for how to create and append a div for each item in dataset: d3.select(\"body\").selectAll(\"div\") .data(dataset) .enter() .append(\"div\") There are a few differences working with rect elements instead of divs. The rects must be appended to an svg element, not directly to the body. Also, you need to tell D3 where to place each rect within the svg area. The bar placement will be covered in the next challenge. Use the data(), enter(), and append() methods to create and append a rect for each item in dataset. The bars should display all on top of each other, this will be fixed in the next challenge. const dataset = [12, 31, 22, 17, 25, 18, 29, 14, 9]; const w = 500; const h = 100; const svg = d3.select(\"body\") .append(\"svg\") .attr(\"width\", w) .attr(\"height\", h); svg.selectAll(\"rect\") // Add your code below this line .data(dataset) .enter() .append(\"rect\") // Add your code above this line .attr(\"x\", 0) .attr(\"y\", 0) .attr(\"width\", 25) .attr(\"height\", 100); "},"data-visualization-certification/data-visualization-with-d3/data-visualization-with-d3-dynamically-set-the-coordinates-for-each-bar.html":{"url":"data-visualization-certification/data-visualization-with-d3/data-visualization-with-d3-dynamically-set-the-coordinates-for-each-bar.html","title":"Data Visualization with D3: Dynamically Set the Coordinates for Each Bar","keywords":"","body":"Data Visualization with D3: Dynamically Set the Coordinates for Each Bar The last challenge created and appended a rectangle to the svg element for each point in dataset to represent a bar. Unfortunately, they were all stacked on top of each other. The placement of a rectangle is handled by the x and y attributes. They tell D3 where to start drawing the shape in the svg area. The last challenge set them each to 0, so every bar was placed in the upper-left corner. For a bar chart, all of the bars should sit on the same vertical level, which means the y value stays the same (at 0) for all bars. The x value, however, needs to change as you add new bars. Remember that larger x values push items farther to the right. As you go through the array elements in dataset, the x value should increase. The attr() method in D3 accepts a callback function to dynamically set that attribute. The callback function takes two arguments, one for the data point itself (usually d) and one for the index of the data point in the array. The second argument for the index is optional. Here's the format: selection.attr(\"property\", (d, i) => { /* d is the data point value i is the index of the data point in the array */ }) It's important to note that you do NOT need to write a for loop or use forEach() to iterate over the items in the data set. Recall that the data() method parses the data set, and any method that's chained after data() is run once for each item in the data set. Change the x attribute callback function so it returns the index times 30. Note Each bar has a width of 25, so increasing each x value by 30 adds some space between the bars. Any value greater than 25 would work in this example. const dataset = [12, 31, 22, 17, 25, 18, 29, 14, 9]; const w = 500; const h = 100; const svg = d3.select(\"body\") .append(\"svg\") .attr(\"width\", w) .attr(\"height\", h); svg.selectAll(\"rect\") .data(dataset) .enter() .append(\"rect\") .attr(\"x\", (d, i) => { // Add your code below this line return i*30; // Add your code above this line }) .attr(\"y\", 0) .attr(\"width\", 25) .attr(\"height\", 100); "},"data-visualization-certification/data-visualization-with-d3/data-visualization-with-d3-dynamically-change-the-height-of-each-bar.html":{"url":"data-visualization-certification/data-visualization-with-d3/data-visualization-with-d3-dynamically-change-the-height-of-each-bar.html","title":"Data Visualization with D3: Dynamically Change the Height of Each Bar","keywords":"","body":"Data Visualization with D3: Dynamically Change the Height of Each Bar The height of each bar can be set to the value of the data point in the array, similar to how the x value was set dynamically. selection.attr(\"property\", (d, i) => { /* d is the data point value i is the index of the data point in the array */ }) Change the callback function for the height attribute to return the data value times 3. Note Remember that multiplying all data points by the same constant scales the data (like zooming in). It helps to see the differences between bar values in this example. const dataset = [12, 31, 22, 17, 25, 18, 29, 14, 9]; const w = 500; const h = 100; const svg = d3.select(\"body\") .append(\"svg\") .attr(\"width\", w) .attr(\"height\", h); svg.selectAll(\"rect\") .data(dataset) .enter() .append(\"rect\") .attr(\"x\", (d, i) => i * 30) .attr(\"y\", 0) .attr(\"width\", 25) .attr(\"height\", (d, i) => { // Add your code below this line return d * 3; // Add your code above this line }); "},"data-visualization-certification/data-visualization-with-d3/data-visualization-with-d3-invert-svg-elements.html":{"url":"data-visualization-certification/data-visualization-with-d3/data-visualization-with-d3-invert-svg-elements.html","title":"Data Visualization with D3: Invert SVG Elements","keywords":"","body":"Data Visualization with D3: Invert SVG Elements You may have noticed the bar chart looked like it's upside-down, or inverted. This is because of how SVG uses (x, y) coordinates. In SVG, the origin point for the coordinates is in the upper-left corner. An x coordinate of 0 places a shape on the left edge of the SVG area. A y coordinate of 0 places a shape on the top edge of the SVG area. Higher x values push the rectangle to the right. Higher y values push the rectangle down. To make the bars right-side-up, you need to change the way the y coordinate is calculated. It needs to account for both the height of the bar and the total height of the SVG area. The height of the SVG area is 100. If you have a data point of 0 in the set, you would want the bar to start at the bottom of the SVG area (not the top). To do this, the y coordinate needs a value of 100. If the data point value were 1, you would start with a y coordinate of 100 to set the bar at the bottom. Then you need to account for the height of the bar of 1, so the final y coordinate would be 99. The y coordinate that is y = heightOfSVG - heightOfBar would place the bars right-side-up. Change the callback function for the y attribute to set the bars right-side-up. Remember that the height of the bar is 3 times the data value d. Note In general, the relationship is y = h - m * d, where m is the constant that scales the data points. const dataset = [12, 31, 22, 17, 25, 18, 29, 14, 9]; const w = 500; const h = 100; const svg = d3.select(\"body\") .append(\"svg\") .attr(\"width\", w) .attr(\"height\", h); svg.selectAll(\"rect\") .data(dataset) .enter() .append(\"rect\") .attr(\"x\", (d, i) => i * 30) .attr(\"y\", (d, i) => { // Add your code below this line return h - 3 * d // Add your code above this line }) .attr(\"width\", 25) .attr(\"height\", (d, i) => 3 * d); "},"data-visualization-certification/data-visualization-with-d3/data-visualization-with-d3-change-the-color-of-an-svg-element.html":{"url":"data-visualization-certification/data-visualization-with-d3/data-visualization-with-d3-change-the-color-of-an-svg-element.html","title":"Data Visualization with D3: Change the Color of an SVG Element","keywords":"","body":"Data Visualization with D3: Change the Color of an SVG Element The bars are in the right position, but they are all the same black color. SVG has a way to change the color of the bars. In SVG, a rect shape is colored with the fill attribute. It supports hex codes, color names, and rgb values, as well as more complex options like gradients and transparency. Add an attr() method to set the \"fill\" of all the bars to the color \"navy\". const dataset = [12, 31, 22, 17, 25, 18, 29, 14, 9]; const w = 500; const h = 100; const svg = d3.select(\"body\") .append(\"svg\") .attr(\"width\", w) .attr(\"height\", h); svg.selectAll(\"rect\") .data(dataset) .enter() .append(\"rect\") .attr(\"x\", (d, i) => i * 30) .attr(\"y\", (d, i) => h - 3 * d) .attr(\"width\", 25) .attr(\"height\", (d, i) => 3 * d) .attr(\"fill\",\"navy\") // Add your code below this line // Add your code above this line "},"data-visualization-certification/data-visualization-with-d3/data-visualization-with-d3-add-labels-to-d3-elements.html":{"url":"data-visualization-certification/data-visualization-with-d3/data-visualization-with-d3-add-labels-to-d3-elements.html","title":"Data Visualization with D3: Add Labels to D3 Elements","keywords":"","body":"Data Visualization with D3: Add Labels to D3 Elements D3 lets you label a graph element, such as a bar, using the SVG text element. Like the rect element, a text element needs to have x and y attributes, to place it on the SVG canvas. It also needs to access the data to display those values. D3 gives you a high level of control over how you label your bars. The code in the editor already binds the data to each new text element. First, append text nodes to the svg. Next, add attributes for the x and y coordinates. They should be calculated the same way as the rect ones, except the y value for the text should make the label sit 3 units higher than the bar. Finally, use the D3 text() method to set the label equal to the data point value. Note For the label to sit higher than the bar, decide if the y value for the text should be 3 greater or 3 less than the y value for the bar. const dataset = [12, 31, 22, 17, 25, 18, 29, 14, 9]; const w = 500; const h = 100; const svg = d3.select(\"body\") .append(\"svg\") .attr(\"width\", w) .attr(\"height\", h); svg.selectAll(\"rect\") .data(dataset) .enter() .append(\"rect\") .attr(\"x\", (d, i) => i * 30) .attr(\"y\", (d, i) => h - 3 * d) .attr(\"width\", 25) .attr(\"height\", (d, i) => 3 * d) .attr(\"fill\", \"navy\"); svg.selectAll(\"text\") .data(dataset) .enter() // Add your code below this line .append(\"text\") .attr(\"x\",(d,i) => i * 30) .attr(\"y\",(d,i) => h - 3 * d - 3) .text((d)=>d); // Add your code above this line "},"data-visualization-certification/data-visualization-with-d3/data-visualization-with-d3-style-d3-labels.html":{"url":"data-visualization-certification/data-visualization-with-d3/data-visualization-with-d3-style-d3-labels.html","title":"Data Visualization with D3: Style D3 Labels","keywords":"","body":"Data Visualization with D3: Style D3 Labels D3 methods can add styles to the bar labels. The fill attribute sets the color of the text for a text node. The style() method sets CSS rules for other styles, such as \"font-family\" or \"font-size\". Set the font-size of the text elements to 25px, and the color of the text to red. const dataset = [12, 31, 22, 17, 25, 18, 29, 14, 9]; const w = 500; const h = 100; const svg = d3.select(\"body\") .append(\"svg\") .attr(\"width\", w) .attr(\"height\", h); svg.selectAll(\"rect\") .data(dataset) .enter() .append(\"rect\") .attr(\"x\", (d, i) => i * 30) .attr(\"y\", (d, i) => h - 3 * d) .attr(\"width\", 25) .attr(\"height\", (d, i) => d * 3) .attr(\"fill\", \"navy\"); svg.selectAll(\"text\") .data(dataset) .enter() .append(\"text\") .text((d) => d) .attr(\"x\", (d, i) => i * 30) .attr(\"y\", (d, i) => h - (3 * d) - 3) // Add your code below this line .attr(\"font-size\",\"25px\") .attr(\"fill\",\"red\") // Add your code above this line "},"data-visualization-certification/data-visualization-with-d3/data-visualization-with-d3-add-a-hover-effect-to-a-d3-element.html":{"url":"data-visualization-certification/data-visualization-with-d3/data-visualization-with-d3-add-a-hover-effect-to-a-d3-element.html","title":"Data Visualization with D3: Add a Hover Effect to a D3 Element","keywords":"","body":"Data Visualization with D3: Add a Hover Effect to a D3 Element It's possible to add effects that highlight a bar when the user hovers over it with the mouse. So far, the styling for the rectangles is applied with the built-in D3 and SVG methods, but you can use CSS as well. You set the CSS class on the SVG elements with the attr() method. Then the :hover pseudo-class for your new class holds the style rules for any hover effects. Use the attr() method to add a class of bar to all the rect elements. This changes the fill color of the bar to brown when you mouse over it. .bar:hover { fill: brown; } const dataset = [12, 31, 22, 17, 25, 18, 29, 14, 9]; const w = 500; const h = 100; const svg = d3.select(\"body\") .append(\"svg\") .attr(\"width\", w) .attr(\"height\", h); svg.selectAll(\"rect\") .data(dataset) .enter() .append(\"rect\") .attr(\"x\", (d, i) => i * 30) .attr(\"y\", (d, i) => h - 3 * d) .attr(\"width\", 25) .attr(\"height\", (d, i) => 3 * d) .attr(\"fill\", \"navy\") // Add your code below this line .attr(\"class\",\"bar\") // Add your code above this line svg.selectAll(\"text\") .data(dataset) .enter() .append(\"text\") .text((d) => d) .attr(\"x\", (d, i) => i * 30) .attr(\"y\", (d, i) => h - (3 * d) - 3); "},"data-visualization-certification/data-visualization-with-d3/data-visualization-with-d3-add-a-tooltip-to-a-d3-element.html":{"url":"data-visualization-certification/data-visualization-with-d3/data-visualization-with-d3-add-a-tooltip-to-a-d3-element.html","title":"Data Visualization with D3: Add a Tooltip to a D3 Element","keywords":"","body":"Data Visualization with D3: Add a Tooltip to a D3 Element A tooltip shows more information about an item on a page when the user hovers over that item. There are several ways to add a tooltip to a visualization, this challenge uses the SVG title element. title pairs with the text() method to dynamically add data to the bars. Append a title element under each rect node. Then call the text() method with a callback function so the text displays the data value. .bar:hover { fill: brown; } const dataset = [12, 31, 22, 17, 25, 18, 29, 14, 9]; const w = 500; const h = 100; const svg = d3.select(\"body\") .append(\"svg\") .attr(\"width\", w) .attr(\"height\", h); svg.selectAll(\"rect\") .data(dataset) .enter() .append(\"rect\") .attr(\"x\", (d, i) => i * 30) .attr(\"y\", (d, i) => h - 3 * d) .attr(\"width\", 25) .attr(\"height\", (d, i) => d * 3) .attr(\"fill\", \"navy\") .attr(\"class\", \"bar\") // Add your code below this line .append(\"title\") .text((d) => d) // Add your code above this line svg.selectAll(\"text\") .data(dataset) .enter() .append(\"text\") .text((d) => d) .attr(\"x\", (d, i) => i * 30) .attr(\"y\", (d, i) => h - (d * 3 + 3)) "},"data-visualization-certification/data-visualization-with-d3/data-visualization-with-d3-create-a-scatterplot-with-svg-circles.html":{"url":"data-visualization-certification/data-visualization-with-d3/data-visualization-with-d3-create-a-scatterplot-with-svg-circles.html","title":"Data Visualization with D3: Create a Scatterplot with SVG Circles","keywords":"","body":"Data Visualization with D3: Create a Scatterplot with SVG Circles A scatter plot is another type of visualization. It usually uses circles to map data points, which have two values each. These values tie to the x and y axes, and are used to position the circle in the visualization. SVG has a circle tag to create the circle shape. It works a lot like the rect elements you used for the bar chart. Use the data(), enter(), and append() methods to bind dataset to new circle elements that are appended to the SVG canvas. const dataset = [ [ 34, 78 ], [ 109, 280 ], [ 310, 120 ], [ 79, 411 ], [ 420, 220 ], [ 233, 145 ], [ 333, 96 ], [ 222, 333 ], [ 78, 320 ], [ 21, 123 ] ]; const w = 500; const h = 500; const svg = d3.select(\"body\") .append(\"svg\") .attr(\"width\", w) .attr(\"height\", h); svg.selectAll(\"circle\") // Add your code below this line .data(dataset) .enter() .append(\"circle\") // Add your code above this line "},"data-visualization-certification/data-visualization-with-d3/data-visualization-with-d3-add-attributes-to-the-circle-elements.html":{"url":"data-visualization-certification/data-visualization-with-d3/data-visualization-with-d3-add-attributes-to-the-circle-elements.html","title":"Data Visualization with D3: Add Attributes to the Circle Elements","keywords":"","body":"Data Visualization with D3: Add Attributes to the Circle Elements The last challenge created the circle elements for each point in the dataset, and appended them to the SVG canvas. But D3 needs more information about the position and size of each circle to display them correctly. A circle in SVG has three main attributes. The cx and cy attributes are the coordinates. They tell D3 where to position the center of the shape on the SVG canvas. The radius (r attribute) gives the size of the circle. Just like the rect y coordinate, the cy attribute for a circle is measured from the top of the SVG canvas, not from the bottom. All three attributes can use a callback function to set their values dynamically. Remember that all methods chained after data(dataset) run once per item in dataset. The d parameter in the callback function refers to the current item in dataset, which is an array for each point. You use bracket notation, like d[0], to access the values in that array. Add cx, cy, and r attributes to the circle elements. The cx value should be the first number in the array for each item in dataset. The cy value should be based off the second number in the array, but make sure to show the chart right-side-up and not inverted. The r value should be 5 for all circles. const dataset = [ [ 34, 78 ], [ 109, 280 ], [ 310, 120 ], [ 79, 411 ], [ 420, 220 ], [ 233, 145 ], [ 333, 96 ], [ 222, 333 ], [ 78, 320 ], [ 21, 123 ] ]; const w = 500; const h = 500; const svg = d3.select(\"body\") .append(\"svg\") .attr(\"width\", w) .attr(\"height\", h); svg.selectAll(\"circle\") .data(dataset) .enter() .append(\"circle\") // Add your code below this line .attr(\"cx\",(d,i) => d[0]) .attr(\"cy\",(d,i) => h-d[1]) .attr(\"r\",\"5\") // Add your code above this line "},"data-visualization-certification/data-visualization-with-d3/data-visualization-with-d3-add-labels-to-scatter-plot-circles.html":{"url":"data-visualization-certification/data-visualization-with-d3/data-visualization-with-d3-add-labels-to-scatter-plot-circles.html","title":"Data Visualization with D3: Add Labels to Scatter Plot Circles","keywords":"","body":"Data Visualization with D3: Add Labels to Scatter Plot Circles You can add text to create labels for the points in a scatter plot. The goal is to display the comma-separated values for the first (x) and second (y) fields of each item in dataset. The text nodes need x and y attributes to position it on the SVG canvas. In this challenge, the y value (which determines height) can use the same value that the circle uses for its cy attribute. The x value can be slightly larger than the cx value of the circle, so the label is visible. This will push the label to the right of the plotted point. Label each point on the scatter plot using the text elements. The text of the label should be the two values separated by a comma and a space. For example, the label for the first point is \"34, 78\". Set the x attribute so it's 5 units more than the value you used for the cx attribute on the circle. Set the y attribute the same way that's used for the cy value on the circle. const dataset = [ [ 34, 78 ], [ 109, 280 ], [ 310, 120 ], [ 79, 411 ], [ 420, 220 ], [ 233, 145 ], [ 333, 96 ], [ 222, 333 ], [ 78, 320 ], [ 21, 123 ] ]; const w = 500; const h = 500; const svg = d3.select(\"body\") .append(\"svg\") .attr(\"width\", w) .attr(\"height\", h); svg.selectAll(\"circle\") .data(dataset) .enter() .append(\"circle\") .attr(\"cx\", (d, i) => d[0]) .attr(\"cy\", (d, i) => h - d[1]) .attr(\"r\", 5); svg.selectAll(\"text\") .data(dataset) .enter() .append(\"text\") // Add your code below this line .attr(\"x\",(d, i) => d[0] + 5) .attr(\"y\",(d, i) => h - d[1]) .text((d)=> d[0]+\", \"+d[1]) // Add your code above this line "},"data-visualization-certification/data-visualization-with-d3/data-visualization-with-d3-create-a-linear-scale-with-d3.html":{"url":"data-visualization-certification/data-visualization-with-d3/data-visualization-with-d3-create-a-linear-scale-with-d3.html","title":"Data Visualization with D3: Create a Linear Scale with D3","keywords":"","body":"Data Visualization with D3: Create a Linear Scale with D3 The bar and scatter plot charts both plotted data directly onto the SVG canvas. However, if the height of a bar or one of the data points were larger than the SVG height or width values, it would go outside the SVG area. In D3, there are scales to help plot data. Scales are functions that tell the program how to map a set of raw data points onto the pixels of the SVG canvas. For example, say you have a 100x500-sized SVG canvas and you want to plot Gross Domestic Product (GDP) for a number of countries. The set of numbers would be in the billion or trillion-dollar range. You provide D3 a type of scale to tell it how to place the large GDP values into that 100x500-sized area. It's unlikely you would plot raw data as-is. Before plotting it, you set the scale for your entire data set, so that the x and y values fit your canvas width and height. D3 has several scale types. For a linear scale (usually used with quantitative data), there is the D3 method scaleLinear(): const scale = d3.scaleLinear() By default, a scale uses the identity relationship. The value of the input is the same as the value of the output. A separate challenge covers how to change this. Change the scale variable to create a linear scale. Then set the output variable to the scale called with an input argument of 50. // Add your code below this line const scale = d3.scaleLinear(); // Create the scale here const output = scale(50); // Call the scale with an argument here // Add your code above this line d3.select(\"body\") .append(\"h2\") .text(output); "},"data-visualization-certification/data-visualization-with-d3/data-visualization-with-d3-set-a-domain-and-a-range-on-a-scale.html":{"url":"data-visualization-certification/data-visualization-with-d3/data-visualization-with-d3-set-a-domain-and-a-range-on-a-scale.html","title":"Data Visualization with D3: Set a Domain and a Range on a Scale","keywords":"","body":"Data Visualization with D3: Set a Domain and a Range on a Scale By default, scales use the identity relationship - the input value maps to the output value. But scales can be much more flexible and interesting. Say a data set has values ranging from 50 to 480. This is the input information for a scale, and is also known as the domain. You want to map those points along the x axis on the SVG canvas, between 10 units and 500 units. This is the output information, which is also known as the range. The domain() and range() methods set these values for the scale. Both methods take an array of at least two elements as an argument. Here's an example: // Set a domain // The domain covers the set of input values scale.domain([50, 480]); // Set a range // The range covers the set of output values scale.range([10, 500]); scale(50) // Returns 10 scale(480) // Returns 500 scale(325) // Returns 323.37 scale(750) // Returns 807.67 d3.scaleLinear() Notice that the scale uses the linear relationship between the domain and range values to figure out what the output should be for a given number. The minimum value in the domain (50) maps to the minimum value (10) in the range. Create a scale and set its domain to [250, 500] and range to [10, 150]. Note You can chain the domain() and range() methods onto the scale variable. // Add your code below this line const scale = d3.scaleLinear(); scale.domain([250,500]); scale.range([10,150]); // Add your code above this line const output = scale(50); d3.select(\"body\") .append(\"h2\") .text(output); "},"data-visualization-certification/data-visualization-with-d3/data-visualization-with-d3-use-the-d3max-and-d3min-functions-to-find-minimum-and-maximum-values-in-a-dataset.html":{"url":"data-visualization-certification/data-visualization-with-d3/data-visualization-with-d3-use-the-d3max-and-d3min-functions-to-find-minimum-and-maximum-values-in-a-dataset.html","title":"Data Visualization with D3: Use the d3.max and d3.min Functions to Find Minimum and Maximum Values in a Dataset","keywords":"","body":"Data Visualization with D3: Use the d3.max and d3.min Functions to Find Minimum and Maximum Values in a Dataset The D3 methods domain() and range() set that information for your scale based on the data. There are a couple methods to make that easier. Often when you set the domain, you'll want to use the minimum and maximum values within the data set. Trying to find these values manually, especially in a large data set, may cause errors. D3 has two methods - min() and max() to return this information. Here's an example: const exampleData = [34, 234, 73, 90, 6, 52]; d3.min(exampleData) // Returns 6 d3.max(exampleData) // Returns 234 A dataset may have nested arrays, like the [x, y] coordinate pairs that were in the scatter plot example. In that case, you need to tell D3 how to calculate the maximum and minimum. Fortunately, both the min() and max() methods take a callback function. In this example, the callback function's argument d is for the current inner array. The callback needs to return the element from the inner array (the x or y value) over which you want to compute the maximum or minimum. Here's an example for how to find the min and max values with an array of arrays: const locationData = [[1, 7],[6, 3],[8, 3]]; // Returns the smallest number out of the first elements const minX = d3.min(locationData, (d) => d[0]); // minX compared 1, 6, and 8 and is set to 1 The positionData variable holds a 3-dimensional (3D) array. Use a D3 method to find the maximum value of the z coordinate (the third value) from the arrays and save it in the output variable. Note Fun fact - D3 can plot 3D arrays. const positionData = [[1, 7, -4],[6, 3, 8],[2, 8, 3]] // Add your code below this line const max = d3.max(positionData, (d) => d[2]) const output = max; // Change this line // Add your code above this line d3.select(\"body\") .append(\"h2\") .text(output) "},"data-visualization-certification/data-visualization-with-d3/data-visualization-with-d3-use-dynamic-scales.html":{"url":"data-visualization-certification/data-visualization-with-d3/data-visualization-with-d3-use-dynamic-scales.html","title":"Data Visualization with D3: Use Dynamic Scales","keywords":"","body":"Data Visualization with D3: Use Dynamic Scales The D3 min() and max() methods are useful to help set the scale. Given a complex data set, one priority is to set the scale so the visualization fits the SVG container's width and height. You want all the data plotted inside the SVG canvas so it's visible on the web page. The example below sets the x-axis scale for scatter plot data. The domain() method passes information to the scale about the raw data values for the plot. The range() method gives it information about the actual space on the web page for the visualization. In the example, the domain goes from 0 to the maximum in the set. It uses the max() method with a callback function based on the x values in the arrays. The range uses the SVG canvas' width (w), but it includes some padding, too. This puts space between the scatter plot dots and the edge of the SVG canvas. const dataset = [ [ 34, 78 ], [ 109, 280 ], [ 310, 120 ], [ 79, 411 ], [ 420, 220 ], [ 233, 145 ], [ 333, 96 ], [ 222, 333 ], [ 78, 320 ], [ 21, 123 ] ]; const w = 500; const h = 500; // Padding between the SVG canvas boundary and the plot const padding = 30; const xScale = d3.scaleLinear() .domain([0, d3.max(dataset, (d) => d[0])]) .range([padding, w - padding]); The padding may be confusing at first. Picture the x-axis as a horizontal line from 0 to 500 (the width value for the SVG canvas). Including the padding in the range() method forces the plot to start at 30 along that line (instead of 0), and end at 470 (instead of 500). Use the yScale variable to create a linear y-axis scale. The domain should start at zero and go to the maximum y value in the set. The range should use the SVG height (h) and include padding. Note Remember to keep the plot right-side-up. When you set the range for the y coordinates, the higher value (height minus padding) is the first argument, and the lower value is the second argument. const dataset = [ [ 34, 78 ], [ 109, 280 ], [ 310, 120 ], [ 79, 411 ], [ 420, 220 ], [ 233, 145 ], [ 333, 96 ], [ 222, 333 ], [ 78, 320 ], [ 21, 123 ] ]; const w = 500; const h = 500; // Padding between the SVG canvas boundary and the plot const padding = 30; // Create an x and y scale const xScale = d3.scaleLinear() .domain([0, d3.max(dataset, (d) => d[0])]) .range([padding, w - padding]); // Add your code below this line const yScale = d3.scaleLinear() .domain([0,d3.max(dataset,(d) => d[1])]) .range([h - padding, padding]); // Add your code above this line const output = yScale(411); // Returns 30 d3.select(\"body\") .append(\"h2\") .text(output) "},"data-visualization-certification/data-visualization-with-d3/data-visualization-with-d3-use-a-pre-defined-scale-to-place-elements.html":{"url":"data-visualization-certification/data-visualization-with-d3/data-visualization-with-d3-use-a-pre-defined-scale-to-place-elements.html","title":"Data Visualization with D3: Use a Pre-Defined Scale to Place Elements","keywords":"","body":"Data Visualization with D3: Use a Pre-Defined Scale to Place Elements With the scales set up, it's time to map the scatter plot again. The scales are like processing functions that turn the x and y raw data into values that fit and render correctly on the SVG canvas. They keep the data within the screen's plotting area. You set the coordinate attribute values for an SVG shape with the scaling function. This includes x and y attributes for rect or text elements, or cx and cy for circles. Here's an example: shape .attr(\"x\", (d) => xScale(d[0])) Scales set shape coordinate attributes to place the data points onto the SVG canvas. You don't need to apply scales when you display the actual data value, for example, in the text() method for a tooltip or label. Use xScale and yScale to position both the circle and text shapes onto the SVG canvas. For the circles, apply the scales to set the cx and cy attributes. Give them a radius of 5 units, too. For the text elements, apply the scales to set the x and y attributes. The labels should be offset to the right of the dots. To do this, add 10 units to the x data value before passing it to the xScale. const dataset = [ [ 34, 78 ], [ 109, 280 ], [ 310, 120 ], [ 79, 411 ], [ 420, 220 ], [ 233, 145 ], [ 333, 96 ], [ 222, 333 ], [ 78, 320 ], [ 21, 123 ] ]; const w = 500; const h = 500; const padding = 60; const xScale = d3.scaleLinear() .domain([0, d3.max(dataset, (d) => d[0])]) .range([padding, w - padding]); const yScale = d3.scaleLinear() .domain([0, d3.max(dataset, (d) => d[1])]) .range([h - padding, padding]); const svg = d3.select(\"body\") .append(\"svg\") .attr(\"width\", w) .attr(\"height\", h); svg.selectAll(\"circle\") .data(dataset) .enter() .append(\"circle\") // Add your code below this line .attr(\"cx\",(d) => xScale(d[0])) .attr(\"cy\",(d) => yScale(d[1])) .attr(\"r\",\"5\") // Add your code above this line svg.selectAll(\"text\") .data(dataset) .enter() .append(\"text\") .text((d) => (d[0] + \", \" + d[1])) // Add your code below this line .attr(\"x\",(d) => xScale(d[0]+10)) .attr(\"y\",(d) => yScale(d[1])) // Add your code above this line "},"data-visualization-certification/data-visualization-with-d3/data-visualization-with-d3-add-axes-to-a-visualization.html":{"url":"data-visualization-certification/data-visualization-with-d3/data-visualization-with-d3-add-axes-to-a-visualization.html","title":"Data Visualization with D3: Add Axes to a Visualization","keywords":"","body":"Data Visualization with D3: Add Axes to a Visualization Another way to improve the scatter plot is to add an x-axis and a y-axis. D3 has two methods axisLeft() and axisBottom() to render the y and x axes, respectively. (Axes is the plural form of axis). Here's an example to create the x-axis based on the xScale in the previous challenges: const xAxis = d3.axisBottom(xScale); The next step is to render the axis on the SVG canvas. To do so, you can use a general SVG component, the g element. The g stands for group. Unlike rect, circle, and text, an axis is just a straight line when it's rendered. Because it is a simple shape, using g works. The last step is to apply a transform attribute to position the axis on the SVG canvas in the right place. Otherwise, the line would render along the border of SVG canvas and wouldn't be visible. SVG supports different types of transforms, but positioning an axis needs translate. When it's applied to the g element, it moves the whole group over and down by the given amounts. Here's an example: const xAxis = d3.axisBottom(xScale); svg.append(\"g\") .attr(\"transform\", \"translate(0, \" + (h - padding) + \")\") .call(xAxis); The above code places the x-axis at the bottom of the SVG canvas. Then it's passed as an argument to the call() method. The y-axis works is the same way, except the translate argument is in the form (x, 0). Because translate is a string in the attr() method above, you can use concatenation to include variable values for its arguments. The scatter plot now has an x-axis. Create a y-axis in a variable named yAxis using the axisLeft() method. Then render the axis using a g element. Make sure to use a transform attribute to translate the axis by the amount of padding units right, and 0 units down. Remember to call() the axis. const dataset = [ [ 34, 78 ], [ 109, 280 ], [ 310, 120 ], [ 79, 411 ], [ 420, 220 ], [ 233, 145 ], [ 333, 96 ], [ 222, 333 ], [ 78, 320 ], [ 21, 123 ] ]; const w = 500; const h = 500; const padding = 60; const xScale = d3.scaleLinear() .domain([0, d3.max(dataset, (d) => d[0])]) .range([padding, w - padding]); const yScale = d3.scaleLinear() .domain([0, d3.max(dataset, (d) => d[1])]) .range([h - padding, padding]); const svg = d3.select(\"body\") .append(\"svg\") .attr(\"width\", w) .attr(\"height\", h); svg.selectAll(\"circle\") .data(dataset) .enter() .append(\"circle\") .attr(\"cx\", (d) => xScale(d[0])) .attr(\"cy\",(d) => yScale(d[1])) .attr(\"r\", (d) => 5); svg.selectAll(\"text\") .data(dataset) .enter() .append(\"text\") .text((d) => (d[0] + \",\" + d[1])) .attr(\"x\", (d) => xScale(d[0] + 10)) .attr(\"y\", (d) => yScale(d[1])) const xAxis = d3.axisBottom(xScale); // Add your code below this line const yAxis = d3.axisLeft(yScale); // Add your code above this line svg.append(\"g\") .attr(\"transform\", \"translate(0,\" + (h - padding) + \")\") .call(xAxis); // Add your code below this line svg.append(\"g\") .attr(\"transform\",\"translate(\" + padding + \", 0)\") .call(yAxis); // Add your code above this line "},"data-visualization-certification/introduction-to-the-json-apis-and-ajax-challenges.html":{"url":"data-visualization-certification/introduction-to-the-json-apis-and-ajax-challenges.html","title":"Introduction to the JSON APIs and AJAX Challenges","keywords":"","body":"Introduction to the JSON APIs and AJAX Challenges Similar to how User Interfaces help people use programs, Application Programming Interfaces (APIs) help programs interact with other programs. APIs are tools that computers use to communicate with one another, in part to send and receive data. You can use API functionality in your page once you understand how to make requests and process data from it. Programmers often use AJAX technologies when working with APIs. The term AJAX originated as an acronym for Asynchronous JavaScript And XML. It refers to a group of technologies that make asynchronous requests to a server to transfer data, then load any returned data into the page. An asynchronous process has a couple key properties. The browser does not stop loading a page to wait for the server's response. Also, the browser inserts updated data into part of the page without having to refresh the entire page. User experience benefits from asynchronous processes in several ways. Pages load faster since the browser isn't waiting for the server to respond in the middle of a page render. Requests and transfers happen in the background, without interrupting what the user is doing. When the browser receives new data, only the necessary area of the page refreshes. These qualities especially enhance the user experience for single page applications. The data transferred between the browser and server is often in a format called JavaScript Object Notation (JSON). JSON resembles JavaScript object literal syntax, except that it's transferred as a string. Once received, it can be converted into an object and used in a script. This section covers how to transfer and use data using AJAX technologies with a freeCodeCamp API. "},"data-visualization-certification/introduction-to-the-json-apis-and-ajax-challenges/json-apis-and-ajax-handle-click-events-with-javascript-using-the-onclick-property.html":{"url":"data-visualization-certification/introduction-to-the-json-apis-and-ajax-challenges/json-apis-and-ajax-handle-click-events-with-javascript-using-the-onclick-property.html","title":"JSON APIs and Ajax: Handle Click Events with JavaScript using the onclick property","keywords":"","body":"JSON APIs and Ajax: Handle Click Events with JavaScript using the onclick property You want your code to execute only once your page has finished loading. For that purpose, you can attach a JavaScript event to the document called DOMContentLoaded. Here's the code that does this: document.addEventListener('DOMContentLoaded',function() { }); You can implement event handlers that go inside of the DOMContentLoaded function. You can implement an onclick event handler which triggers when the user clicks on the element with id getMessage, by adding the following code: document.getElementById('getMessage').onclick=function(){}; Add a click event handler inside of the DOMContentLoaded function for the element with id of getMessage. document.addEventListener('DOMContentLoaded',function(){ // Add your code below this line document.getElementById('getMessage').onclick = function(){ }; // Add your code above this line }); body { text-align: center; font-family: \"Helvetica\", sans-serif; } h1 { font-size: 2em; font-weight: bold; } .box { border-radius: 5px; background-color: #eee; padding: 20px 5px; } button { color: white; background-color: #4791d0; border-radius: 5px; border: 1px solid #4791d0; padding: 5px 10px 8px 10px; } button:hover { background-color: #0F5897; border: 1px solid #0F5897; } Cat Photo Finder The message will go here Get Message "},"data-visualization-certification/introduction-to-the-json-apis-and-ajax-challenges/json-apis-and-ajax-change-text-with-click-events.html":{"url":"data-visualization-certification/introduction-to-the-json-apis-and-ajax-challenges/json-apis-and-ajax-change-text-with-click-events.html","title":"JSON APIs and Ajax: Change Text with click Events","keywords":"","body":"JSON APIs and Ajax: Change Text with click Events When the click event happens, you can use JavaScript to update an HTML element. For example, when a user clicks the \"Get Message\" button, it changes the text of the element with the class message to say \"Here is the message\". This works by adding the following code within the click event: document.getElementsByClassName('message')[0].textContent=\"Here is the message\"; Add code inside the onclick event handler to change the text inside the message element to say \"Here is the message\". document.addEventListener('DOMContentLoaded',function(){ document.getElementById('getMessage').onclick=function(){ // Add your code below this line document.getElementsByClassName('message')[0].textContent=\"Here is the message\"; // Add your code above this line } }); body { text-align: center; font-family: \"Helvetica\", sans-serif; } h1 { font-size: 2em; font-weight: bold; } .box { border-radius: 5px; background-color: #eee; padding: 20px 5px; } button { color: white; background-color: #4791d0; border-radius: 5px; border: 1px solid #4791d0; padding: 5px 10px 8px 10px; } button:hover { background-color: #0F5897; border: 1px solid #0F5897; } Cat Photo Finder The message will go here Get Message "},"data-visualization-certification/introduction-to-the-json-apis-and-ajax-challenges/json-apis-and-ajax-get-json-with-the-javascript-xmlhttprequest-method.html":{"url":"data-visualization-certification/introduction-to-the-json-apis-and-ajax-challenges/json-apis-and-ajax-get-json-with-the-javascript-xmlhttprequest-method.html","title":"JSON APIs and Ajax: Get JSON with the JavaScript XMLHttpRequest Method","keywords":"","body":"JSON APIs and Ajax: Get JSON with the JavaScript XMLHttpRequest Method You can also request data from an external source. This is where APIs come into play. Remember that APIs - or Application Programming Interfaces - are tools that computers use to communicate with one another. You'll learn how to update HTML with the data we get from APIs using a technology called AJAX. Most web APIs transfer data in a format called JSON. JSON stands for JavaScript Object Notation. JSON syntax looks very similar to JavaScript object literal notation. JSON has object properties and their current values, sandwiched between a { and a }. These properties and their values are often referred to as \"key-value pairs\". However, JSON transmitted by APIs are sent as bytes, and your application receives it as a string. These can be converted into JavaScript objects, but they are not JavaScript objects by default. The JSON.parse method parses the string and constructs the JavaScript object described by it. You can request the JSON from freeCodeCamp's Cat Photo API. Here's the code you can put in your click event to do this: req=new XMLHttpRequest(); req.open(\"GET\",'/json/cats.json',true); req.send(); req.onload=function(){ json=JSON.parse(req.responseText); document.getElementsByClassName('message')[0].innerHTML=JSON.stringify(json); }; Here's a review of what each piece is doing. The JavaScript XMLHttpRequest object has a number of properties and methods that are used to transfer data. First, an instance of the XMLHttpRequest object is created and saved in the req variable. Next, the open method initializes a request - this example is requesting data from an API, therefore is a \"GET\" request. The second argument for open is the URL of the API you are requesting data from. The third argument is a Boolean value where true makes it an asynchronous request. The send method sends the request. Finally, the onload event handler parses the returned data and applies the JSON.stringify method to convert the JavaScript object into a string. This string is then inserted as the message text. Update the code to create and send a \"GET\" request to the freeCodeCamp Cat Photo API. Then click the \"Get Message\" button. Your AJAX function will replace the \"The message will go here\" text with the raw JSON output from the API. document.addEventListener('DOMContentLoaded',function(){ document.getElementById('getMessage').onclick=function(){ // Add your code below this line req=new XMLHttpRequest(); req.open(\"GET\",'/json/cats.json',true); req.send(); req.onload=function(){ json=JSON.parse(req.responseText); document.getElementsByClassName('message')[0].innerHTML=JSON.stringify(json); }; // Add your code above this line }; }); body { text-align: center; font-family: \"Helvetica\", sans-serif; } h1 { font-size: 2em; font-weight: bold; } .box { border-radius: 5px; background-color: #eee; padding: 20px 5px; } button { color: white; background-color: #4791d0; border-radius: 5px; border: 1px solid #4791d0; padding: 5px 10px 8px 10px; } button:hover { background-color: #0F5897; border: 1px solid #0F5897; } Cat Photo Finder The message will go here Get Message "},"data-visualization-certification/introduction-to-the-json-apis-and-ajax-challenges/json-apis-and-ajax-access-the-json-data-from-an-api.html":{"url":"data-visualization-certification/introduction-to-the-json-apis-and-ajax-challenges/json-apis-and-ajax-access-the-json-data-from-an-api.html","title":"JSON APIs and Ajax: Access the JSON Data from an API","keywords":"","body":"JSON APIs and Ajax: Access the JSON Data from an API In the previous challenge, you saw how to get JSON data from the freeCodeCamp Cat Photo API. Now you'll take a closer look at the returned data to better understand the JSON format. Recall some notation in JavaScript: [ ] -> Square brackets represent an array { } -> Curly brackets represent an object \" \" -> Double quotes represent a string. They are also used for key names in JSON Understanding the structure of the data that an API returns is important because it influences how you retrieve the values you need. On the right, click the \"Get Message\" button to load the freeCodeCamp Cat Photo API JSON into the HTML. The first and last character you see in the JSON data are square brackets [ ]. This means that the returned data is an array. The second character in the JSON data is a curly { bracket, which starts an object. Looking closely, you can see that there are three separate objects. The JSON data is an array of three objects, where each object contains information about a cat photo. You learned earlier that objects contain \"key-value pairs\" that are separated by commas. In the Cat Photo example, the first object has \"id\":0 where \"id\" is a key and 0 is its corresponding value. Similarly, there are keys for \"imageLink\", \"altText\", and \"codeNames\". Each cat photo object has these same keys, but with different values. Another interesting \"key-value pair\" in the first object is \"codeNames\":[\"Juggernaut\",\"Mrs. Wallace\",\"ButterCup\"]. Here \"codeNames\" is the key and its value is an array of three strings. It's possible to have arrays of objects as well as a key with an array as a value. Remember how to access data in arrays and objects. Arrays use bracket notation to access a specific index of an item. Objects use either bracket or dot notation to access the value of a given property. Here's an example that prints the \"altText\" of the first cat photo - note that the parsed JSON data in the editor is saved in a variable called json: console.log(json[0].altText); // Prints \"A white cat wearing a green helmet shaped melon on its head.\" For the cat with the \"id\" of 2, print to the console the second value in the codeNames array. You should use bracket and dot notation on the object (which is saved in the variable json) to access the value. document.addEventListener('DOMContentLoaded',function(){ document.getElementById('getMessage').onclick=function(){ req=new XMLHttpRequest(); req.open(\"GET\",'/json/cats.json',true); req.send(); req.onload=function(){ json=JSON.parse(req.responseText); document.getElementsByClassName('message')[0].innerHTML=JSON.stringify(json); // Add your code below this line console.log(json[2].codeNames[1]); // Add your code above this line }; }; }); body { text-align: center; font-family: \"Helvetica\", sans-serif; } h1 { font-size: 2em; font-weight: bold; } .box { border-radius: 5px; background-color: #eee; padding: 20px 5px; } button { color: white; background-color: #4791d0; border-radius: 5px; border: 1px solid #4791d0; padding: 5px 10px 8px 10px; } button:hover { background-color: #0F5897; border: 1px solid #0F5897; } Cat Photo Finder The message will go here Get Message "},"data-visualization-certification/introduction-to-the-json-apis-and-ajax-challenges/json-apis-and-ajax-convert-json-data-to-html.html":{"url":"data-visualization-certification/introduction-to-the-json-apis-and-ajax-challenges/json-apis-and-ajax-convert-json-data-to-html.html","title":"JSON APIs and Ajax: Convert JSON Data to HTML","keywords":"","body":"JSON APIs and Ajax: Convert JSON Data to HTML Now that you're getting data from a JSON API, you can display it in the HTML. You can use a forEach method to loop through the data since the cat photo objects are held in an array. As you get to each item, you can modify the HTML elements. First, declare an html variable with var html = \"\";. Then, loop through the JSON, adding HTML to the variable that wraps the key names in strong tags, followed by the value. When the loop is finished, you render it. Here's the code that does this: json.forEach(function(val) { var keys = Object.keys(val); html += \"\"; keys.forEach(function(key) { html += \"\" + key + \": \" + val[key] + \"\"; }); html += \"\"; }); Add a forEach method to loop over the JSON data and create the HTML elements to display it. Here is some example JSON [ { \"id\":0, \"imageLink\":\"https://s3.amazonaws.com/freecodecamp/funny-cat.jpg\", \"altText\":\"A white cat wearing a green helmet shaped melon on its head. \", \"codeNames\":[ \"Juggernaut\", \"Mrs. Wallace\", \"Buttercup\" ] } ] document.addEventListener('DOMContentLoaded',function(){ document.getElementById('getMessage').onclick=function(){ req=new XMLHttpRequest(); req.open(\"GET\",'/json/cats.json',true); req.send(); req.onload=function(){ json=JSON.parse(req.responseText); var html = \"\"; // Add your code below this line json.forEach(function(val) { var keys = Object.keys(val); html += \"\"; keys.forEach(function(key) { html += \"\" + key + \": \" + val[key] + \"\"; }); html += \"\"; }); // Add your code above this line document.getElementsByClassName('message')[0].innerHTML=html; }; }; }); body { text-align: center; font-family: \"Helvetica\", sans-serif; } h1 { font-size: 2em; font-weight: bold; } .box { border-radius: 5px; background-color: #eee; padding: 20px 5px; } button { color: white; background-color: #4791d0; border-radius: 5px; border: 1px solid #4791d0; padding: 5px 10px 8px 10px; } button:hover { background-color: #0F5897; border: 1px solid #0F5897; } Cat Photo Finder The message will go here Get Message "},"data-visualization-certification/introduction-to-the-json-apis-and-ajax-challenges/json-apis-and-ajax-render-images-from-data-sources.html":{"url":"data-visualization-certification/introduction-to-the-json-apis-and-ajax-challenges/json-apis-and-ajax-render-images-from-data-sources.html","title":"JSON APIs and Ajax: Render Images from Data Sources","keywords":"","body":"JSON APIs and Ajax: Render Images from Data Sources The last few challenges showed that each object in the JSON array contains an imageLink key with a value that is the URL of a cat's image. When you're looping through these objects, you can use this imageLink property to display this image in an img element. Here's the code that does this: html += \"\"; Add code to use the imageLink and altText properties in an img tag. document.addEventListener('DOMContentLoaded',function(){ document.getElementById('getMessage').onclick=function(){ req=new XMLHttpRequest(); req.open(\"GET\",'/json/cats.json',true); req.send(); req.onload=function(){ json=JSON.parse(req.responseText); var html = \"\"; json.forEach(function(val) { html += \"\"; // Add your code below this line html += \"\"; // Add your code above this line html += \"\"; }); document.getElementsByClassName('message')[0].innerHTML=html; }; }; }); body { text-align: center; font-family: \"Helvetica\", sans-serif; } h1 { font-size: 2em; font-weight: bold; } .box { border-radius: 5px; background-color: #eee; padding: 20px 5px; } button { color: white; background-color: #4791d0; border-radius: 5px; border: 1px solid #4791d0; padding: 5px 10px 8px 10px; } button:hover { background-color: #0F5897; border: 1px solid #0F5897; } Cat Photo Finder The message will go here Get Message "},"data-visualization-certification/introduction-to-the-json-apis-and-ajax-challenges/json-apis-and-ajax-pre-filter-json-to-get-the-data-you-need.html":{"url":"data-visualization-certification/introduction-to-the-json-apis-and-ajax-challenges/json-apis-and-ajax-pre-filter-json-to-get-the-data-you-need.html","title":"JSON APIs and Ajax: Pre-filter JSON to Get the Data You Need","keywords":"","body":"JSON APIs and Ajax: Pre-filter JSON to Get the Data You Need If you don't want to render every cat photo you get from the freeCodeCamp Cat Photo API, you can pre-filter the JSON before looping through it. Given that the JSON data is stored in an array, you can use the filter method to filter out the cat whose \"id\" key has a value of 1. Here's the code to do this: json = json.filter(function(val) { return (val.id !== 1); }); Add code to filter the json data to remove the cat with the \"id\" value of 1. document.addEventListener('DOMContentLoaded',function(){ document.getElementById('getMessage').onclick=function(){ req=new XMLHttpRequest(); req.open(\"GET\",'/json/cats.json',true); req.send(); req.onload=function(){ json=JSON.parse(req.responseText); var html = \"\"; // Add your code below this line json = json.filter(function(val) { return (val.id !== 1); }); // Add your code above this line json.forEach(function(val) { html += \"\" html += \"\" html += \"\" }); document.getElementsByClassName('message')[0].innerHTML=html; }; }; }); body { text-align: center; font-family: \"Helvetica\", sans-serif; } h1 { font-size: 2em; font-weight: bold; } .box { border-radius: 5px; background-color: #eee; padding: 20px 5px; } button { color: white; background-color: #4791d0; border-radius: 5px; border: 1px solid #4791d0; padding: 5px 10px 8px 10px; } button:hover { background-color: #0F5897; border: 1px solid #0F5897; } Cat Photo Finder The message will go here Get Message "},"data-visualization-certification/introduction-to-the-json-apis-and-ajax-challenges/json-apis-and-ajax-get-geolocation-data-to-find-a-users-gps-coordinates.html":{"url":"data-visualization-certification/introduction-to-the-json-apis-and-ajax-challenges/json-apis-and-ajax-get-geolocation-data-to-find-a-users-gps-coordinates.html","title":"JSON APIs and Ajax: Get Geolocation Data to Find A User's GPS Coordinates","keywords":"","body":"JSON APIs and Ajax: Get Geolocation Data to Find A User's GPS Coordinates Another cool thing you can do is access your user's current location. Every browser has a built in navigator that can give you this information. The navigator will get the user's current longitude and latitude. You will see a prompt to allow or block this site from knowing your current location. The challenge can be completed either way, as long as the code is correct. By selecting allow, you will see the text on the output phone change to your latitude and longitude. Here's code that does this: if (navigator.geolocation){ navigator.geolocation.getCurrentPosition(function(position) { document.getElementById('data').innerHTML=\"latitude: \"+ position.coords.latitude + \"longitude: \" + position.coords.longitude; }); } First, it checks if the navigator.geolocation object exists. If it does, the getCurrentPosition method on that object is called, which initiates an asynchronous request for the user's position. If the request is successful, the callback function in the method runs. This function accesses the position object's values for latitude and longitude using dot notation and updates the HTML. Add the example code inside the script tags to check a user's current location and insert it into the HTML. // Add your code below this line if (navigator.geolocation){ navigator.geolocation.getCurrentPosition(function(position) { document.getElementById('data').innerHTML=\"latitude: \"+ position.coords.latitude + \"longitude: \" + position.coords.longitude; }); } // Add your code above this line You are here: "},"data-visualization-certification/introduction-to-the-json-apis-and-ajax-challenges/json-apis-and-ajax-post-data-with-the-javascript-xmlhttprequest-method.html":{"url":"data-visualization-certification/introduction-to-the-json-apis-and-ajax-challenges/json-apis-and-ajax-post-data-with-the-javascript-xmlhttprequest-method.html","title":"JSON APIs and Ajax: Post Data with the JavaScript XMLHttpRequest Method","keywords":"","body":"JSON APIs and Ajax: Post Data with the JavaScript XMLHttpRequest Method In the previous examples, you received data from an external resource. You can also send data to an external resource, as long as that resource supports AJAX requests and you know the URL. JavaScript's XMLHttpRequest method is also used to post data to a server. Here's an example: req=new XMLHttpRequest(); req.open(\"POST\",url,true); req.setRequestHeader('Content-Type','text/plain'); req.onreadystatechange=function(){ if(req.readyState==4 && req.status==200){ document.getElementsByClassName('message')[0].innerHTML=req.responseText; } }; req.send(userName); You've seen several of these methods before. Here the open method initializes the request as a \"POST\" to the given URL of the external resource, and uses the true Boolean to make it asynchronous. The setRequestHeader method sets the value of an HTTP request header, which contains information about the sender and the request. It must be called after the open method, but before the send method. The two parameters are the name of the header and the value to set as the body of that header. Next, the onreadystatechange event listener handles a change in the state of the request. A readyState of 4 means the operation is complete, and a status of 200 means it was a successful request. The document's HTML can be updated. Finally, the send method sends the request with the userName value, which was given by the user in the input field. Update the code to create and send a \"POST\" request. Then enter your name in input box and click \"Send Message\". Your AJAX function will replace \"Reply from Server will be here.\" with the reply of the server. In this case, it is your name appended with \" loves cats\". document.addEventListener('DOMContentLoaded',function(){ document.getElementById('sendMessage').onclick=function(){ var userName=document.getElementById('name').value; // Add your code below this line req=new XMLHttpRequest(); req.open(\"POST\",url,true); req.setRequestHeader('Content-Type','text/plain'); req.onreadystatechange=function(){ if(req.readyState==4 && req.status==200){ document.getElementsByClassName('message')[0].innerHTML=req.responseText; } }; req.send(userName); // Add your code above this line }; }); body { text-align: center; font-family: \"Helvetica\", sans-serif; } h1 { font-size: 2em; font-weight: bold; } .box { border-radius: 5px; background-color: #eee; padding: 20px 5px; } button { color: white; background-color: #4791d0; border-radius: 5px; border: 1px solid #4791d0; padding: 5px 10px 8px 10px; } button:hover { background-color: #0F5897; border: 1px solid #0F5897; } Cat Friends Reply from Server will be here Your name: Send Message "},"apis-and-microservices-certification/managing-packages-with-npm.html":{"url":"apis-and-microservices-certification/managing-packages-with-npm.html","title":"Managing Packages with Npm","keywords":"","body":"Introduction to the Managing Packages with npm Challenges The Node Package Manager (npm) is a command-line tool used by developers to share and control modules (or packages) of JavaScript code written for use with Node.js. When starting a new project, npm generates a package.json file. This file lists the package dependencies for your project. Since npm packages are regularly updated, the package.json file allows you to set specific version numbers for each dependency. This ensures that updates to a package don't break your project. npm saves packages in a folder named nodemodules. These packages can be installed in two ways: globally in a root nodemodules folder, accessible by all projects. locally within a project's own node_modules folder, accessible only to that project. Most developers prefer to install packages local to each project to create a separation between the dependencies of different projects. Working on these challenges will involve you writing your code on Glitch on our starter project. After completing each challenge you can copy your public Glitch url (to the homepage of your app) into the challenge screen to test it! Optionally you may choose to write your project on another platform but it must be publicly visible for our testing. Start this project on Glitch using this link or clone this repository on GitHub! If you use Glitch, remember to save the link to your project somewhere safe! "},"apis-and-microservices-certification/managing-packages-with-npm/managing-packages-with-npm-how-to-use-packagejson-the-core-of-any-nodejs-project-or-npm-package.html":{"url":"apis-and-microservices-certification/managing-packages-with-npm/managing-packages-with-npm-how-to-use-packagejson-the-core-of-any-nodejs-project-or-npm-package.html","title":"Managing Packages with Npm - How to Use package.json, the Core of Any Node.js Project or npm Package","keywords":"","body":"Managing Packages with Npm - How to Use package.json, the Core of Any Node.js Project or npm Package The file package.json is the center of any Node.js project or npm package. It stores information about your project just like the -section in a HTML document describes the content of a webpage. The package.json consists of a single JSON-object where information is stored in \"key\": value-pairs. There are only two required fields in a minimal package.json - name and version - but it’s a good practice to provide additional information about your project that could be useful to future users or maintainers. The author-field If you go to the Glitch project that you set up previously and look at on the left side of your screen, you’ll find the file tree where you can see an overview of the various files in your project. Under the file tree’s back-end section, you’ll find package.json - the file that we’ll be improving in the next couple of challenges. One of the most common pieces of information in this file is the author-field that specifies who’s the creator of a project. It can either be a string or an object with contact details. The object is recommended for bigger projects but in our case, a simple string like the following example will do. \"author\": \"Jane Doe\", Instructions Add your name to the author-field in the package.json of your Glitch project. Remember that you’re writing JSON. All field-names must use double-quotes (\"), e.g. \"author\" All fields must be separated with a comma (,) - fork [glitch boilerplate-npm](https://glitch.com/#!/import/github/freeCodeCamp/boilerplate-npm) - add`\"author\": \"Jane Doe\",` to package.json - click share，copy the `Share your App` url "},"apis-and-microservices-certification/basic-node-and-express.html":{"url":"apis-and-microservices-certification/basic-node-and-express.html","title":"Basic Node and Express","keywords":"","body":"Introduction to the Basic Node and Express Challenges Node.js is a JavaScript tool that allows developers to write backend (server-side) programs in JavaScript. Node.js comes with a handful of built-in modules—small, independent programs—that help facilitate this purpose. Some of the core modules include: HTTP: a module that acts as a server File System: a module that reads and modifies files Path: a module for working with directory and file paths Assertion Testing: a module that checks code against prescribed constraints Express, while not included with Node.js, is another module often used with it. Express runs between the server created by Node.js and the frontend pages of a web application. Express also handles an application's routing. Routing directs users to the correct page based on their interaction with the application. While there are alternatives to using Express, its simplicity makes it a good place to begin when learning the interaction between a backend powered by Node.js and the frontend. Working on these challenges will involve you writing your code on Glitch on our starter project. After completing each challenge you can copy your public Glitch url (to the homepage of your app) into the challenge screen to test it! Optionally you may choose to write your project on another platform but it must be publicly visible for our testing. Start this project on Glitch using this link or clone this repository on GitHub! If you use Glitch, remember to save the link to your project somewhere safe! "},"apis-and-microservices-certification/basic-node-and-express/basic-node-and-express-meet-the-node-console.html":{"url":"apis-and-microservices-certification/basic-node-and-express/basic-node-and-express-meet-the-node-console.html","title":"Basic Node and Express - Meet the Node console","keywords":"","body":"Basic Node and Express - Meet the Node console During the development process, it is important to be able to check what’s going on in your code. Node is just a JavaScript environment. Like client side JavaScript, you can use the console to display useful debug information. On your local machine, you would see the console output in a terminal. On Glitch you can open the logs in the lower part of the screen. You can toggle the log panel with the button ‘Logs’ (top-left, under the app name). To get started, just print the classic \"Hello World\" in the console. We recommend to keep the log panel open while working at these challenges. Reading the logs you can be aware of the nature of the errors that may occur. "}}